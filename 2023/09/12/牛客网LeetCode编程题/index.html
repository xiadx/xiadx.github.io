<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Algorithm," />










<meta name="description" content="牛客网LeetCode编程题 二叉树的最小深度描述  求给定二叉树的最小深度。最小深度是指树的根结点到最近叶子结点的最短路径上结点的数量  123456789101112131415161718192021222324&#x2F;** * struct TreeNode &amp;#123; *	int val; *	struct TreeNode *left; *	struct TreeNode *right;">
<meta property="og:type" content="article">
<meta property="og:title" content="牛客网LeetCode编程题">
<meta property="og:url" content="http://example.com/2023/09/12/%E7%89%9B%E5%AE%A2%E7%BD%91LeetCode%E7%BC%96%E7%A8%8B%E9%A2%98/index.html">
<meta property="og:site_name" content="Dingxin&#39;s BLOG">
<meta property="og:description" content="牛客网LeetCode编程题 二叉树的最小深度描述  求给定二叉树的最小深度。最小深度是指树的根结点到最近叶子结点的最短路径上结点的数量  123456789101112131415161718192021222324&#x2F;** * struct TreeNode &amp;#123; *	int val; *	struct TreeNode *left; *	struct TreeNode *right;">
<meta property="og:locale">
<meta property="article:published_time" content="2023-09-12T08:27:00.000Z">
<meta property="article:modified_time" content="2023-11-17T11:50:03.571Z">
<meta property="article:author" content="Dingxin">
<meta property="article:tag" content="Algorithm">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/2023/09/12/牛客网LeetCode编程题/"/>





  <title>牛客网LeetCode编程题 | Dingxin's BLOG</title>
  








<meta name="generator" content="Hexo 6.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Dingxin's BLOG</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/12/%E7%89%9B%E5%AE%A2%E7%BD%91LeetCode%E7%BC%96%E7%A8%8B%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dingxin's BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">牛客网LeetCode编程题</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-09-12T16:27:00+08:00">
                2023-09-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/ta/classic-code">牛客网LeetCode编程题</a></p>
<h2 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h2><p>描述</p>
<blockquote>
<p>求给定二叉树的最小深度。最小深度是指树的根结点到最近叶子结点的最短路径上结点的数量</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *	int val;</span><br><span class="line"> *	struct TreeNode *left;</span><br><span class="line"> *	struct TreeNode *right;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param root TreeNode类 </span><br><span class="line">     * @return int整型</span><br><span class="line">     */</span><br><span class="line">    int run(TreeNode* root) &#123;</span><br><span class="line">        if (root == nullptr) return 0;</span><br><span class="line">        int left = run(root-&gt;left);</span><br><span class="line">        int right = run(root-&gt;right);</span><br><span class="line">        if (left == 0) return right + 1;</span><br><span class="line">        else if (right == 0) return left + 1;</span><br><span class="line">        else return min(left, right) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *  int val;</span><br><span class="line"> *  struct TreeNode *left;</span><br><span class="line"> *  struct TreeNode *right;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param root TreeNode类 </span><br><span class="line">     * @return int整型</span><br><span class="line">     */</span><br><span class="line">    int run(TreeNode* root) &#123;</span><br><span class="line">        if (root == nullptr) return 0;</span><br><span class="line">        queue&lt;TreeNode *&gt; q;</span><br><span class="line">        root-&gt;val = 1;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            TreeNode *cur = q.front();</span><br><span class="line">            if (cur-&gt;left == nullptr &amp;&amp; cur-&gt;right == nullptr) return cur-&gt;val;</span><br><span class="line">            if (cur-&gt;left) &#123;</span><br><span class="line">               q.push(cur-&gt;left);</span><br><span class="line">               cur-&gt;left-&gt;val = cur-&gt;val + 1; </span><br><span class="line">            &#125;</span><br><span class="line">            if (cur-&gt;right) &#123;</span><br><span class="line">                q.push(cur-&gt;right);</span><br><span class="line">                cur-&gt;right-&gt;val = cur-&gt;val + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="后缀表达式求值"><a href="#后缀表达式求值" class="headerlink" title="后缀表达式求值"></a>后缀表达式求值</h2><p>描述</p>
<blockquote>
<p>计算逆波兰式（后缀表达式）的值<br>运算符仅包含”+”,”-“,”*”和”&#x2F;“，被操作数是整数<br>保证表达式合法，除法时向下取整。</p>
</blockquote>
<blockquote>
<p>数据范围：表达式的长度满足： n&lt;&#x3D;1000<br>进阶：空间复杂度 O(n) 时间复杂度 O(n)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param tokens string字符串vector </span><br><span class="line">     * @return int整型</span><br><span class="line">     */</span><br><span class="line">    bool isOperator(string token) &#123;</span><br><span class="line">        return (token == &quot;+&quot; || token == &quot;-&quot; || token == &quot;*&quot; || token == &quot;/&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;</span><br><span class="line">        int n = tokens.size();</span><br><span class="line">        if (n == 0) return 0;</span><br><span class="line">        stack&lt;int&gt; s;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            if (!isOperator(tokens[i])) &#123;</span><br><span class="line">                s.push(stoi(tokens[i]));</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                int b = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                int a = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                if (tokens[i] == &quot;+&quot;) s.push(a+b);</span><br><span class="line">                if (tokens[i] == &quot;-&quot;) s.push(a-b);</span><br><span class="line">                if (tokens[i] == &quot;*&quot;) s.push(a*b);</span><br><span class="line">                if (tokens[i] == &quot;/&quot;) s.push(a/b); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="多少个点位于同一直线"><a href="#多少个点位于同一直线" class="headerlink" title="多少个点位于同一直线"></a>多少个点位于同一直线</h2><p>描述</p>
<blockquote>
<p>对于给定的n个位于同一二维平面上的点，求最多能有多少个点位于同一直线上</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * struct Point &#123;</span><br><span class="line"> *	int x;</span><br><span class="line"> *	int y;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param points Point类vector </span><br><span class="line">     * @return int整型</span><br><span class="line">     */</span><br><span class="line">    int gcd(int a, int b) &#123;</span><br><span class="line">        return b == 0 ? a : gcd(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line">    int maxPoints(vector&lt;Point&gt;&amp; points) &#123;</span><br><span class="line">        int n = points.size();</span><br><span class="line">        if (n &lt;= 2) return n;</span><br><span class="line">        int max_points = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            map&lt;pair&lt;int, int&gt;, int&gt; mp;</span><br><span class="line">            int dup = 1;</span><br><span class="line">            for (int j = i + 1; j &lt; n; ++j) &#123;</span><br><span class="line">                int x = points[j].x - points[i].x;</span><br><span class="line">                int y = points[j].y - points[i].y;</span><br><span class="line">                if (x == 0 &amp;&amp; y == 0) dup++;</span><br><span class="line">                else &#123;</span><br><span class="line">                    int g = gcd(x, y);</span><br><span class="line">                    x /= g;</span><br><span class="line">                    y /= g;</span><br><span class="line">                    mp[&#123;x, y&#125;]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            max_points = max(max_points, dup);</span><br><span class="line">            for (auto it = mp.begin(); it != mp.end(); ++it) &#123;</span><br><span class="line">                max_points = max(max_points, dup + it-&gt;second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max_points;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * struct Point &#123;</span><br><span class="line"> *  int x;</span><br><span class="line"> *  int y;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#include &lt;cfloat&gt;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param points Point类vector </span><br><span class="line">     * @return int整型</span><br><span class="line">     */</span><br><span class="line">    int maxPoints(vector&lt;Point&gt;&amp; points) &#123;</span><br><span class="line">        int n = points.size();</span><br><span class="line">        if (n &lt;= 2) return n;</span><br><span class="line">        int max_points = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            map&lt;float, int&gt; mp;</span><br><span class="line">            int dup = 1;</span><br><span class="line">            for (int j = i + 1; j &lt; n; ++j) &#123;</span><br><span class="line">                int x = points[j].x - points[i].x;</span><br><span class="line">                int y = points[j].y - points[i].y;</span><br><span class="line">                if (x == 0 &amp;&amp; y == 0) ++dup;</span><br><span class="line">                else &#123;</span><br><span class="line">                    if (x == 0) mp[FLT_MAX]++;</span><br><span class="line">                    else mp[(1.0 * y)/x]++; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            max_points = max(max_points, dup);</span><br><span class="line">            for (auto it = mp.begin(); it != mp.end(); ++it) &#123;</span><br><span class="line">                max_points = max(max_points, it-&gt;second + dup);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max_points;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="链表排序"><a href="#链表排序" class="headerlink" title="链表排序"></a>链表排序</h2><p>描述</p>
<blockquote>
<p>在O(n log n)的时间内使用常数级空间复杂度对链表进行排序</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *  int val;</span><br><span class="line"> *  struct ListNode *next;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param head ListNode类 </span><br><span class="line">     * @return ListNode类</span><br><span class="line">     */</span><br><span class="line">    ListNode* merge(ListNode* h1, ListNode* h2) &#123;</span><br><span class="line">        if (h1 == nullptr) return h2;</span><br><span class="line">        if (h2 == nullptr) return h1;</span><br><span class="line">        if (h1-&gt;val &lt; h2-&gt;val) &#123;</span><br><span class="line">            h1-&gt;next = merge(h1-&gt;next, h2);</span><br><span class="line">            return h1;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            h2-&gt;next = merge(h1, h2-&gt;next);</span><br><span class="line">            return h2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* middle(ListNode* h) &#123;</span><br><span class="line">        if (h == nullptr) return nullptr;</span><br><span class="line">        ListNode *slow = h, *fast = slow-&gt;next;</span><br><span class="line">        while (slow &amp;&amp; fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return slow;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* sortList(ListNode* head) &#123;</span><br><span class="line">        if (head == nullptr || head-&gt;next == nullptr) return head;</span><br><span class="line">        ListNode *m = middle(head);</span><br><span class="line">        ListNode *h1 = head;</span><br><span class="line">        ListNode *h2 = m-&gt;next;</span><br><span class="line">        m-&gt;next = nullptr;</span><br><span class="line">        h1 = sortList(h1);</span><br><span class="line">        h2 = sortList(h2);</span><br><span class="line">        return merge(h1, h2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="链表的插入排序"><a href="#链表的插入排序" class="headerlink" title="链表的插入排序"></a>链表的插入排序</h2><p>描述</p>
<blockquote>
<p>使用插入排序对链表进行排序</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *  int val;</span><br><span class="line"> *  struct ListNode *next;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param head ListNode类 </span><br><span class="line">     * @return ListNode类</span><br><span class="line">     */</span><br><span class="line">    ListNode* insertionSortList(ListNode* head) &#123;</span><br><span class="line">        if (head == nullptr || head-&gt;next == nullptr) return head;</span><br><span class="line">        ListNode *dummy = new ListNode(0);</span><br><span class="line">        ListNode *cur = head, *nxt;</span><br><span class="line">        while (cur) &#123;</span><br><span class="line">            nxt = cur-&gt;next;</span><br><span class="line">            ListNode *pre = dummy;</span><br><span class="line">            while (pre-&gt;next &amp;&amp; pre-&gt;next-&gt;val &lt; cur-&gt;val) pre = pre-&gt;next;</span><br><span class="line">            cur-&gt;next = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = cur;</span><br><span class="line">            cur = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a>二叉树的后序遍历</h2><p>描述<br>用递归的方法对给定的二叉树进行后序遍历</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *  int val;</span><br><span class="line"> *  struct TreeNode *left;</span><br><span class="line"> *  struct TreeNode *right;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param root TreeNode类 </span><br><span class="line">     * @return int整型vector</span><br><span class="line">     */</span><br><span class="line">    vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if (root == nullptr) return res;</span><br><span class="line">        stack&lt;TreeNode *&gt; s1, s2;</span><br><span class="line">        s1.push(root);</span><br><span class="line">        while (!s1.empty()) &#123;</span><br><span class="line">            TreeNode *cur = s1.top();</span><br><span class="line">            s1.pop();</span><br><span class="line">            if (cur-&gt;left) s1.push(cur-&gt;left);</span><br><span class="line">            if (cur-&gt;right) s1.push(cur-&gt;right);</span><br><span class="line">            s2.push(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        while (!s2.empty()) &#123;</span><br><span class="line">            TreeNode * cur = s2.top();</span><br><span class="line">            res.push_back(cur-&gt;val);</span><br><span class="line">            s2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="求二叉树的前序遍历"><a href="#求二叉树的前序遍历" class="headerlink" title="求二叉树的前序遍历"></a>求二叉树的前序遍历</h2><p>描述</p>
<blockquote>
<p>求给定的二叉树的前序遍历</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *  int val;</span><br><span class="line"> *  struct TreeNode *left;</span><br><span class="line"> *  struct TreeNode *right;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param root TreeNode类 </span><br><span class="line">     * @return int整型vector</span><br><span class="line">     */</span><br><span class="line">    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if (root == nullptr) return res;</span><br><span class="line">        stack&lt;TreeNode *&gt; s;</span><br><span class="line">        TreeNode *cur = root;</span><br><span class="line">        while (!s.empty() || cur) &#123;</span><br><span class="line">            while (cur) &#123;</span><br><span class="line">                res.push_back(cur-&gt;val);</span><br><span class="line">                s.push(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a>重排链表</h2><p>描述</p>
<blockquote>
<p>将给定的单链表L: L0-&gt;L1-&gt;…-&gt;Ln-1-&gt;Ln<br>重新排序为：L0-&gt;Ln-&gt;L1-&gt;Ln-1-&gt;…-&gt;<br>要求使用原地算法，不能只改变节点内部的值，需要对实际的节点进行交换</p>
</blockquote>
<blockquote>
<p>数据范围：链表长度 0 &lt;&#x3D; n &lt;&#x3D; 20000 链表中每个节点的值满足 0 &lt;&#x3D; val &lt;&#x3D; 1000</p>
</blockquote>
<blockquote>
<p>要求：空间复杂度 O(n) 并在链表上进行操作而不新建链表，时间复杂度 O(n)<br>进阶：空间复杂度 O(1) 时间复杂度 O(n)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *reverse_list(ListNode *head) &#123;</span><br><span class="line">        ListNode *pre = nullptr, *cur = head, *nxt = nullptr;</span><br><span class="line">        while (cur) &#123;</span><br><span class="line">            nxt = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        return pre;</span><br><span class="line">    &#125;</span><br><span class="line">    void reorderList(ListNode *head) &#123;</span><br><span class="line">        if (!head || !head-&gt;next) return;</span><br><span class="line">        ListNode *slow = head, *fast = head-&gt;next;</span><br><span class="line">        while (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *l1 = head, *l2 = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = nullptr;</span><br><span class="line">        l2 = reverse_list(l2);</span><br><span class="line">        ListNode *p = l1, *q = l2, *t;</span><br><span class="line">        while (q) &#123;</span><br><span class="line">            t = q-&gt;next;</span><br><span class="line">            q-&gt;next = p-&gt;next;</span><br><span class="line">            p-&gt;next = q;</span><br><span class="line">            p = q-&gt;next;</span><br><span class="line">            q = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="链表中环的入口结点"><a href="#链表中环的入口结点" class="headerlink" title="链表中环的入口结点"></a>链表中环的入口结点</h2><p>描述</p>
<blockquote>
<p>给一个长度为n链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) :</span><br><span class="line">        val(x), next(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* EntryNodeOfLoop(ListNode* pHead) &#123;</span><br><span class="line">        if (pHead == nullptr) return nullptr;</span><br><span class="line">        ListNode *cur = pHead;</span><br><span class="line">        map&lt;ListNode *, int&gt; mp;</span><br><span class="line">        while (cur) &#123;</span><br><span class="line">            mp[cur]++;</span><br><span class="line">            if (mp[cur] == 2) return cur;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="判断链表中是否有环"><a href="#判断链表中是否有环" class="headerlink" title="判断链表中是否有环"></a>判断链表中是否有环</h2><p>描述</p>
<blockquote>
<p>判断给定的链表中是否有环。如果有环则返回true，否则返回false</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasCycle(ListNode *head) &#123;</span><br><span class="line">        if (head == nullptr) return false;</span><br><span class="line">        map&lt;ListNode *, int&gt; mp;</span><br><span class="line">        while (head) &#123;</span><br><span class="line">            mp[head]++;</span><br><span class="line">            if (mp[head] == 2) return true;</span><br><span class="line">            head = head -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="拆分词句"><a href="#拆分词句" class="headerlink" title="拆分词句"></a>拆分词句</h2><p>描述</p>
<blockquote>
<p>给定一个字符串s和一组单词dict，判断s是否可以用空格分割成一个单词序列，使得单词序列中所有的单词都是dict中的单词（序列可以包含一个或多个单词）<br>例如:<br>给定s&#x3D;“nowcode”<br>dict&#x3D;[“now”, “code”]<br>返回true，因为”nowcode”可以被分割成”now code”</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool wordBreak(string s, unordered_set&lt;string&gt; &amp;dict) &#123;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        if (n == 0) return true;</span><br><span class="line">        vector&lt;bool&gt; dp(n+1, false);</span><br><span class="line">        dp[0] = true;</span><br><span class="line">        for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; i; ++j) &#123;</span><br><span class="line">                if (dp[j] &amp;&amp; dict.find(s.substr(j, i-j)) != dict.end()) dp[i] = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="出现一次的数字ii"><a href="#出现一次的数字ii" class="headerlink" title="出现一次的数字ii"></a>出现一次的数字ii</h2><p>描述</p>
<blockquote>
<p>现在有一个整数类型的数组，数组中只有一个元素只出现一次，其余元素都出现三次。你需要找出只出现一次的元素<br>数据范围： 数组长度满足 0 &lt;&#x3D; n &lt;&#x3D; 4000 数组中每个元素的值满足 0 &lt;&#x3D; val &lt;&#x3D; 2147483648<br>进阶: 空间复杂度 O(1) 时间复杂度 O(n)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param A int整型一维数组 </span><br><span class="line">     * @param n int A数组长度</span><br><span class="line">     * @return int整型</span><br><span class="line">     */</span><br><span class="line">    int singleNumber(int* A, int n) &#123;</span><br><span class="line">        if (!A || n == 0) return 0;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 0; i &lt; 32; ++i) &#123;</span><br><span class="line">            int bit = 0;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                bit += (A[j] &gt;&gt; i) &amp; 1;</span><br><span class="line">            &#125;</span><br><span class="line">            res += (bit % 3) &lt;&lt; i;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="出现一次的数字"><a href="#出现一次的数字" class="headerlink" title="出现一次的数字"></a>出现一次的数字</h2><p>描述</p>
<blockquote>
<p>现在有一个整数类型的数组，数组中素只有一个元素只出现一次，其余的元素都出现两次<br>数据范围：0 &lt; n &lt;&#x3D; 4000  数组中每个值满足 0 &lt;&#x3D; val &lt;&#x3D; 4000<br>进阶： 空间复杂度 O(1) 时间复杂度 O(n)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param A int整型一维数组 </span><br><span class="line">     * @param n int A数组长度</span><br><span class="line">     * @return int整型</span><br><span class="line">     */</span><br><span class="line">    int singleNumber(int* A, int n) &#123;</span><br><span class="line">        if (n == 0) return -1;</span><br><span class="line">        if (n == 1) return A[0];</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            res ^= A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="分糖果"><a href="#分糖果" class="headerlink" title="分糖果"></a>分糖果</h2><p>描述</p>
<blockquote>
<p>有N个小朋友站在一排，每个小朋友都有一个评分<br>你现在要按以下的规则给孩子们分糖果：<br>每个小朋友至少要分得一颗糖果<br>分数高的小朋友要他比旁边得分低的小朋友分得的糖果多<br>你最少要分发多少颗糖果</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param ratings int整型vector </span><br><span class="line">     * @return int整型</span><br><span class="line">     */</span><br><span class="line">    int candy(vector&lt;int&gt;&amp; ratings) &#123;</span><br><span class="line">        int n = ratings.size();</span><br><span class="line">        if (n == 0) return 0;</span><br><span class="line">        if (n == 1) return 1;</span><br><span class="line">        vector&lt;int&gt; dp(n, 1);</span><br><span class="line">        bool flag = true;</span><br><span class="line">        while (flag) &#123;</span><br><span class="line">            flag = false;</span><br><span class="line">            for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">                if (ratings[i] &gt; ratings[i-1] &amp;&amp; dp[i] &lt;= dp[i-1]) &#123;</span><br><span class="line">                    flag = true;</span><br><span class="line">                    dp[i] = dp[i-1] + 1;   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int j = n - 2; j &gt;= 0; --j) &#123;</span><br><span class="line">                if (ratings[j] &gt; ratings[j+1] &amp;&amp; dp[j] &lt;= dp[j+1]) &#123;</span><br><span class="line">                    flag = true;</span><br><span class="line">                    dp[j] = dp[j+1] + 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            res += dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h2><p>描述</p>
<blockquote>
<p>环形路上有n个加油站，第i个加油站的汽油量是gas[i].<br>你有一辆车，车的油箱可以无限装汽油。从加油站i走到下一个加油站（i+1）花费的油量是cost[i]，你从一个加油站出发，刚开始的时候油箱里面没有汽油<br>求从哪个加油站出发可以在环形路上走一圈。返回加油站的下标，如果没有答案的话返回-1<br>注意：答案保证唯一</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param gas int整型vector </span><br><span class="line">     * @param cost int整型vector </span><br><span class="line">     * @return int整型</span><br><span class="line">     */</span><br><span class="line">    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;</span><br><span class="line">        int n = gas.size();</span><br><span class="line">        if (n == 0) return -1;</span><br><span class="line">        for (int p = 0; p &lt; n; ++p) &#123;</span><br><span class="line">            int t = 0, g = 0;</span><br><span class="line">            int i = p;</span><br><span class="line">            while (t &lt; n &amp;&amp; i &lt; n &amp;&amp; (g + gas[i] - cost[i]) &gt;= 0) &#123;</span><br><span class="line">                 g += (gas[i] - cost[i]);</span><br><span class="line">                 ++i;</span><br><span class="line">                 ++t;</span><br><span class="line">                 if (i == n) i = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            if (t == n) return p;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param gas int整型vector </span><br><span class="line">     * @param cost int整型vector </span><br><span class="line">     * @return int整型</span><br><span class="line">     */</span><br><span class="line">    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;</span><br><span class="line">        int n = gas.size();</span><br><span class="line">        if (n == 0) return -1;</span><br><span class="line">        int sum = 0, cur = 0, idx = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            sum += (gas[i] - cost[i]);</span><br><span class="line">            cur += (gas[i] - cost[i]);</span><br><span class="line">            if (cur &lt; 0) &#123;</span><br><span class="line">                cur = 0;</span><br><span class="line">                idx = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum &gt;= 0 ? idx + 1 : -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="复制无向图"><a href="#复制无向图" class="headerlink" title="复制无向图"></a>复制无向图</h2><p>描述</p>
<blockquote>
<p>本题要求复制一个无向图，图中每个节点都包含一个标签和它的邻居列表</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for undirected graph.</span><br><span class="line"> * struct UndirectedGraphNode &#123;</span><br><span class="line"> *     int label;</span><br><span class="line"> *     vector&lt;UndirectedGraphNode *&gt; neighbors;</span><br><span class="line"> *     UndirectedGraphNode(int x) : label(x) &#123;&#125;;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(UndirectedGraphNode *node, map&lt;UndirectedGraphNode *, UndirectedGraphNode *&gt; &amp;mp) &#123;</span><br><span class="line">        if (node == nullptr) return;</span><br><span class="line">        if (mp[node]) return;</span><br><span class="line">        mp[node] = new UndirectedGraphNode(node-&gt;label);</span><br><span class="line">        for (auto it : node-&gt;neighbors) &#123;</span><br><span class="line">            dfs(it, mp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) &#123;</span><br><span class="line">        if (node == nullptr) return nullptr;</span><br><span class="line">        map&lt;UndirectedGraphNode *, UndirectedGraphNode *&gt; mp;</span><br><span class="line">        dfs(node, mp);</span><br><span class="line">        for (auto it = mp.begin(); it != mp.end(); ++it) &#123;</span><br><span class="line">            for (auto cur : it-&gt;first-&gt;neighbors) &#123;</span><br><span class="line">                it-&gt;second-&gt;neighbors.push_back(cur);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return mp[node];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="分割回文串-ii"><a href="#分割回文串-ii" class="headerlink" title="分割回文串-ii"></a>分割回文串-ii</h2><p>描述</p>
<blockquote>
<p>给出一个字符串s，分割s使得分割出的每一个子串都是回文串<br>计算将字符串s分割成回文分割结果的最小切割数<br>例如:给定字符串s&#x3D;”aab”,<br>返回1，因为回文分割结果[“aa”,”b”]是切割一次生成的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param s string字符串 </span><br><span class="line">     * @return int整型</span><br><span class="line">     */</span><br><span class="line">    int minCut(string s) &#123;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        if (n == 0) return 0;</span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;bool&gt; &gt; path(n, vector&lt;bool&gt;(n, false));</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) path[i][i] = true;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; i; ++j) &#123;</span><br><span class="line">                if (s[j] == s[i] &amp;&amp; i - j &lt; 2) path[j][i] = true;</span><br><span class="line">                else if (s[j] == s[i] &amp;&amp; i - j &gt;=2 ) path[j][i] = path[j+1][i-1];</span><br><span class="line">                else continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; dp(n+1, INT_MAX);</span><br><span class="line">        dp[0] = -1;</span><br><span class="line">        for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">            for (int j = i-1; j &gt;= 0; --j) &#123;</span><br><span class="line">                if (path[j][i-1]) &#123;</span><br><span class="line">                    dp[i] = min(dp[i], dp[j] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h2><p>描述</p>
<blockquote>
<p>给定一个字符串s，分割s使得s的每一个子串都是回文串<br>返回所有的回文分割结果。（注意：返回结果的顺序需要和输入字符串中的字母顺序一致</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param s string字符串 </span><br><span class="line">     * @return string字符串vector&lt;vector&lt;&gt;&gt;</span><br><span class="line">     */</span><br><span class="line">    bool is_palindrome(string s) &#123;</span><br><span class="line">        // int n = s.size();</span><br><span class="line">        // if (n &lt;= 1) return true;</span><br><span class="line">        // for (int i = 0, j = n-1; i &lt;= j; ++i, --j) &#123;</span><br><span class="line">        //     if (s[i] != s[j]) return false;</span><br><span class="line">        // &#125;</span><br><span class="line">        // return true;</span><br><span class="line">        return (s == string(s.rbegin(), s.rend()));</span><br><span class="line">    &#125;</span><br><span class="line">    void dfs(vector&lt;vector&lt;string&gt; &gt; &amp;res, vector&lt;string&gt; &amp;path, string s, int index) &#123;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        if (n == index) &#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= n-index; ++i) &#123;</span><br><span class="line">            if (is_palindrome(s.substr(index, i))) &#123;</span><br><span class="line">                path.push_back(s.substr(index, i));</span><br><span class="line">                dfs(res, path, s, index+i);</span><br><span class="line">                path.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt; &gt; partition(string s) &#123;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        vector&lt;vector&lt;string&gt; &gt; res;</span><br><span class="line">        vector&lt;string&gt; path;</span><br><span class="line">        if (n == 0) return res;</span><br><span class="line">        dfs(res, path, s, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="包围区域"><a href="#包围区域" class="headerlink" title="包围区域"></a>包围区域</h2><p>描述</p>
<blockquote>
<p>现在有一个仅包含‘X’和‘O’的二维板，请捕获所有的被‘X’包围的区域<br>捕获一个被包围区域的方法是将被包围区域中的所有‘O’变成‘X’</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(vector&lt;vector&lt;char&gt; &gt; &amp;board, int i, int j) &#123;</span><br><span class="line">        int m = board.size();</span><br><span class="line">        if (m == 0) return;</span><br><span class="line">        int n = board[0].size();</span><br><span class="line">        if (i &lt; 0 || j &lt; 0 || i &gt;= m || j &gt;= n) return;</span><br><span class="line">        if (board[i][j] != &#x27;O&#x27;) return;</span><br><span class="line">        board[i][j] = &#x27;A&#x27;;</span><br><span class="line">        dfs(board, i+1, j);</span><br><span class="line">        dfs(board, i-1, j);</span><br><span class="line">        dfs(board, i, j-1);</span><br><span class="line">        dfs(board, i, j+1);</span><br><span class="line">    &#125;</span><br><span class="line">    void solve(vector&lt;vector&lt;char&gt;&gt; &amp;board) &#123;</span><br><span class="line">        int m = board.size();</span><br><span class="line">        if (m == 0) return;</span><br><span class="line">        int n = board[0].size();</span><br><span class="line">        for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">            dfs(board, i, 0);</span><br><span class="line">            dfs(board, i, n-1);</span><br><span class="line">        &#125;</span><br><span class="line">        for  (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">            dfs(board, 0, j);</span><br><span class="line">            dfs(board, m-1, j);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (board[i][j] == &#x27;O&#x27;) board[i][j] = &#x27;X&#x27;;</span><br><span class="line">                if (board[i][j] == &#x27;A&#x27;) board[i][j] = &#x27;O&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="二叉树根节点到叶子节点的所有路径和"><a href="#二叉树根节点到叶子节点的所有路径和" class="headerlink" title="二叉树根节点到叶子节点的所有路径和"></a>二叉树根节点到叶子节点的所有路径和</h2><p>描述</p>
<blockquote>
<p>给定一个二叉树的根节点root，该树的节点值都在数字0−9 之间，每一条从根节点到叶子节点的路径都可以用一个数字表示<br>1.该题路径定义为从树的根结点开始往下一直到叶子结点所经过的结点<br>2.叶子节点是指没有子节点的节点<br>3.路径只能从父节点到子节点，不能从子节点到父节点<br>4.总节点数目为n</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *  int val;</span><br><span class="line"> *  struct TreeNode *left;</span><br><span class="line"> *  struct TreeNode *right;</span><br><span class="line"> *  TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="line">     *</span><br><span class="line">     * </span><br><span class="line">     * @param root TreeNode类 </span><br><span class="line">     * @return int整型</span><br><span class="line">     */</span><br><span class="line">    void dfs(vector&lt;vector&lt;int&gt; &gt; &amp;res, vector&lt;int&gt; &amp;path, TreeNode *root) &#123;</span><br><span class="line">        if (root == nullptr) return;</span><br><span class="line">        path.push_back(root-&gt;val);</span><br><span class="line">        dfs(res, path, root-&gt;left);</span><br><span class="line">        dfs(res, path, root-&gt;right);</span><br><span class="line">        if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr) res.push_back(path);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    int sumNumbers(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">        vector&lt;int&gt; path;</span><br><span class="line">        dfs(res, path, root);</span><br><span class="line">        int n = res.size();</span><br><span class="line">        if (n == 0) return 0;</span><br><span class="line">        int total = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            int m = res[i].size();</span><br><span class="line">            int sum = 0;</span><br><span class="line">            for (int j = 0; j &lt; m; ++j) &#123;</span><br><span class="line">                sum = 10 * sum + res[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            total += sum;</span><br><span class="line">        &#125;</span><br><span class="line">        return total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *  int val;</span><br><span class="line"> *  struct TreeNode *left;</span><br><span class="line"> *  struct TreeNode *right;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param root TreeNode类 </span><br><span class="line">     * @return int整型</span><br><span class="line">     */</span><br><span class="line">    void dfs(TreeNode *root, int path, int &amp;sum) &#123;</span><br><span class="line">        if (!root) return;</span><br><span class="line">        path = 10 * path + root-&gt;val;</span><br><span class="line">        if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr) &#123;</span><br><span class="line">            sum += path;</span><br><span class="line">        &#125; </span><br><span class="line">        dfs(root-&gt;left, path, sum);</span><br><span class="line">        dfs(root-&gt;right, path, sum);</span><br><span class="line">        </span><br><span class="line">//         path = path / 10;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    int sumNumbers(TreeNode* root) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        int path = 0;</span><br><span class="line">        dfs(root, path, sum);</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最长的连续元素序列长度"><a href="#最长的连续元素序列长度" class="headerlink" title="最长的连续元素序列长度"></a>最长的连续元素序列长度</h2><p>描述</p>
<blockquote>
<p>给定一个无序的整数类型数组，求最长的连续元素序列的长度<br>例如：<br>给出的数组为[1000, 4, 2000, 1, 3, 2],<br>最长的连续元素序列为[1, 2, 3, 4]. 返回这个序列的长度：4<br>你需要给出时间复杂度在O（n）之内的算法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param num int整型vector </span><br><span class="line">     * @return int整型</span><br><span class="line">     */</span><br><span class="line">    int longestConsecutive(vector&lt;int&gt;&amp; num) &#123;</span><br><span class="line">        int n = num.size();</span><br><span class="line">        if (n == 0) return 0;</span><br><span class="line">        map&lt;int, int&gt; mp;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) mp[num[i]]++;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (auto it = mp.begin(); it != mp.end(); ++it) &#123;</span><br><span class="line">            if (mp[it-&gt;first] &gt; 0) &#123;</span><br><span class="line">                int l = 1;</span><br><span class="line">                int i = it-&gt;first + 1;</span><br><span class="line">                while (mp[i] &gt;= 1) &#123;</span><br><span class="line">                    ++l;</span><br><span class="line">                    mp[i] = 0;</span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;</span><br><span class="line">                i = it-&gt;first - 1;</span><br><span class="line">                while (mp[i] &gt;= 1) &#123;</span><br><span class="line">                    ++l;</span><br><span class="line">                    mp[i] = 0;</span><br><span class="line">                    --i;</span><br><span class="line">                &#125;</span><br><span class="line">                mp[it-&gt;first] = 0;</span><br><span class="line">                res = max(res, l);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="词语序列"><a href="#词语序列" class="headerlink" title="词语序列"></a>词语序列</h2><p>描述</p>
<blockquote>
<p>给定两个单词（初始单词和目标单词）和一个单词字典，请找出所有的从初始单词到目标单词的最短转换序列的长度<br>每一次转换只能改变一个单词<br>每一个中间词都必须存在单词字典当中</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int ladderLength(string start, string end, unordered_set&lt;string&gt; &amp;dict) &#123;</span><br><span class="line">        queue&lt;string&gt; q;</span><br><span class="line">        unordered_set&lt;string&gt; s;</span><br><span class="line">        q.push(start);</span><br><span class="line">        s.emplace(start);</span><br><span class="line">        int res = 1;</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            int q_size = q.size();</span><br><span class="line">            while (q_size--) &#123;</span><br><span class="line">                string cur = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                if (cur == end) return res;</span><br><span class="line">                int n = cur.size();</span><br><span class="line">                for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">                    string nxt(cur);</span><br><span class="line">                    for (int j = &#x27;a&#x27;; j &lt;= &#x27;z&#x27;; ++j) &#123;</span><br><span class="line">                        if (nxt[i] == j) continue;</span><br><span class="line">                        nxt[i] = j;</span><br><span class="line">                        // if (s.find(nxt) != s.end() || dict.find(nxt) == dict.end()) continue;</span><br><span class="line">                        if (s.count(nxt) || !dict.count(nxt)) continue;</span><br><span class="line">                        s.emplace(nxt);</span><br><span class="line">                        q.push(nxt);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="判断回文串"><a href="#判断回文串" class="headerlink" title="判断回文串"></a>判断回文串</h2><p>描述</p>
<blockquote>
<p>判断题目给出的字符串是不是回文，仅考虑字符串中的字母字符和数字字符，并且忽略大小写<br>例如：”nowcoder Is Best tsebsi: redoc won”是回文  “race a car”不是回文<br>注意：<br>你有没有考虑过字符串可能为空？这是面试时应该提出的一个好问题<br>针对这个问题，我们定义空字符串是回文</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param s string字符串 </span><br><span class="line">     * @return bool布尔型</span><br><span class="line">     */</span><br><span class="line">    bool isPalindrome(string s) &#123;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        if (n == 0) return true;</span><br><span class="line">        int index = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            if (s[i] &gt;= &#x27;A&#x27; &amp;&amp; s[i] &lt;= &#x27;Z&#x27;) &#123;</span><br><span class="line">                s[index++] = s[i] - &#x27;A&#x27; + &#x27;a&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">            else if ((s[i] &gt;= &#x27;a&#x27; &amp;&amp; s[i] &lt;= &#x27;z&#x27;) || (s[i] &gt;= &#x27;0&#x27; &amp;&amp; s[i] &lt;= &#x27;9&#x27;)) &#123;</span><br><span class="line">                s[index++] = s[i];</span><br><span class="line">            &#125;</span><br><span class="line">            else continue;</span><br><span class="line">        &#125;</span><br><span class="line">        string a = s.substr(0, index);</span><br><span class="line">        return a == string(a.rbegin(), a.rend());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树中的最大路径和"><a href="#二叉树中的最大路径和" class="headerlink" title="二叉树中的最大路径和"></a>二叉树中的最大路径和</h2><blockquote>
<p>描述<br>二叉树里面的路径被定义为:从该树的任意节点出发，经过父&#x3D;&gt;子或者子&#x3D;&gt;父的连接，达到任意节点的序列<br>注意:<br>1.同一个节点在一条二叉树路径里中最多出现一次<br>2.一条路径至少包含一个节点，且不一定经过根节点</p>
</blockquote>
<blockquote>
<p>给定一个二叉树的根节点root，请你计算它的最大路径和</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *  int val;</span><br><span class="line"> *  struct TreeNode *left;</span><br><span class="line"> *  struct TreeNode *right;</span><br><span class="line"> *  TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="line">     *</span><br><span class="line">     * </span><br><span class="line">     * @param root TreeNode类 </span><br><span class="line">     * @return int整型</span><br><span class="line">     */</span><br><span class="line">    int dfs(TreeNode *root, int &amp;ans) &#123;</span><br><span class="line">        if (!root) return 0;</span><br><span class="line">        int left_sum = max(dfs(root-&gt;left, ans), 0);</span><br><span class="line">        int right_sum = max(dfs(root-&gt;right, ans), 0);</span><br><span class="line">        ans = max(ans, left_sum + right_sum + root-&gt;val);</span><br><span class="line">        return max(left_sum, right_sum) + root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    int maxPathSum(TreeNode* root) &#123;</span><br><span class="line">        if (!root) return 0;</span><br><span class="line">        int ans = INT_MIN;</span><br><span class="line">        dfs(root, ans);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="买卖股票的最好时机-iii"><a href="#买卖股票的最好时机-iii" class="headerlink" title="买卖股票的最好时机 iii"></a>买卖股票的最好时机 iii</h2><p>描述</p>
<blockquote>
<p>假设你有一个数组，其中第i个元素是某只股票在第i天的价格<br>设计一个算法来求最大的利润。你最多可以进行两次交易<br>注意:<br>你不能同时进行多个交易(即，你必须在再次购买之前出售之前买的股票)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param prices int整型vector </span><br><span class="line">     * @return int整型</span><br><span class="line">     */</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        int n = prices.size();</span><br><span class="line">        if (n == 0) return 0;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; dp(n, vector&lt;int&gt;(5, 0));</span><br><span class="line">        dp[0][1] = -prices[0];</span><br><span class="line">        dp[0][2] = 0;</span><br><span class="line">        dp[0][3] = -prices[0];</span><br><span class="line">        dp[0][4] = 0;</span><br><span class="line">        for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i][0] = 0;</span><br><span class="line">            dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]);</span><br><span class="line">            dp[i][2] = max(dp[i-1][2], dp[i-1][1] + prices[i]);</span><br><span class="line">            dp[i][3] = max(dp[i-1][3], dp[i-1][2] - prices[i]);</span><br><span class="line">            dp[i][4] = max(dp[i-1][4], dp[i-1][3] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n-1][4];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="买卖股票的最好时机-ii"><a href="#买卖股票的最好时机-ii" class="headerlink" title="买卖股票的最好时机 ii"></a>买卖股票的最好时机 ii</h2><p>描述</p>
<blockquote>
<p>假设你有一个数组，其中第i个元素表示某只股票在第i天的价格。<br>设计一个算法来寻找最大的利润。你可以完成任意数量的交易(例如，多次购买和出售股票的一股)。但是，你不能同时进行多个交易(即，你必须在再次购买之前卖出之前买的股票)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param prices int整型vector </span><br><span class="line">     * @return int整型</span><br><span class="line">     */</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        int n = prices.size();</span><br><span class="line">        if (n == 0 || n == 1) return 0;</span><br><span class="line">        int max_profit = 0;</span><br><span class="line">        for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">            if (prices[i] &gt; prices[i-1]) max_profit += prices[i] - prices[i-1];</span><br><span class="line">        &#125;</span><br><span class="line">        return max_profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="买卖股票的最好时机"><a href="#买卖股票的最好时机" class="headerlink" title="买卖股票的最好时机"></a>买卖股票的最好时机</h2><p>描述</p>
<blockquote>
<p>假设你有一个数组prices，长度为n，其中prices[i]是股票在第i天的价格，请根据这个价格数组，返回买卖股票能获得的最大收益<br>1.你可以买入一次股票和卖出一次股票，并非每天都可以买入或卖出一次，总共只能买入和卖出一次，且买入必须在卖出的前面的某一天<br>2.如果不能获取到任何利润，请返回0<br>3.假设买入卖出均无手续费</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="line">     *</span><br><span class="line">     * </span><br><span class="line">     * @param prices int整型vector </span><br><span class="line">     * @return int整型</span><br><span class="line">     */</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        int n = prices.size();</span><br><span class="line">        if (n == 0) return 0;</span><br><span class="line">        int min_value = prices[0];</span><br><span class="line">        int max_profit = 0;</span><br><span class="line">        for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">            max_profit = max(max_profit, prices[i] - min_value);</span><br><span class="line">            min_value = min(min_value, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return max_profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="三角形"><a href="#三角形" class="headerlink" title="三角形"></a>三角形</h2><p>描述</p>
<blockquote>
<p>给出一个三角形，计算从三角形顶部到底部的最小路径和，每一步都可以移动到下面一行相邻的数字</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minimumTotal(vector&lt;vector&lt;int&gt; &gt; &amp;triangle) &#123;</span><br><span class="line">        int n = triangle.size();</span><br><span class="line">        if (n == 0) return 0;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; dp(n, vector&lt;int&gt;(n, 0));</span><br><span class="line">        dp[0][0] = triangle[0][0];</span><br><span class="line">        for (int j = 1; j &lt; n; ++j) &#123;</span><br><span class="line">            dp[j][0] = dp[j-1][0] + triangle[j][0];</span><br><span class="line">            dp[j][j] = dp[j-1][j-1] + triangle[j][j];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 1; j &lt; i; ++j) &#123;</span><br><span class="line">                dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return *min_element(dp[n-1].begin(), dp[n-1].end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minimumTotal(vector&lt;vector&lt;int&gt; &gt; &amp;triangle) &#123;</span><br><span class="line">        int n = triangle.size();</span><br><span class="line">        if (n == 0) return 0;</span><br><span class="line">        for (int i = n - 2; i &gt;= 0; --i) &#123;</span><br><span class="line">            for (int j = 0; j &lt;= i; ++j) &#123;</span><br><span class="line">                triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return triangle[0][0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="杨辉三角-ii"><a href="#杨辉三角-ii" class="headerlink" title="杨辉三角-ii"></a>杨辉三角-ii</h2><p>描述</p>
<blockquote>
<p>给出一个索引k，返回杨辉三角的第k行<br>例如，k&#x3D;3，<br>返回[1,3,3,1].<br>备注：<br>你能将你的算法优化到只使用O(k)的额外空间吗?</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param rowIndex int整型 </span><br><span class="line">     * @return int整型vector</span><br><span class="line">     */</span><br><span class="line">    vector&lt;int&gt; getRow(int rowIndex) &#123;</span><br><span class="line">        int n = rowIndex;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; dp(n+1, vector&lt;int&gt;(n+1, 1));</span><br><span class="line">        for (int i = 2; i &lt;= n; ++i) &#123;</span><br><span class="line">            for (int j = 1; j &lt; i; ++j) &#123;</span><br><span class="line">                dp[i][j] = dp[i-1][j-1]+dp[i-1][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param rowIndex int整型 </span><br><span class="line">     * @return int整型vector</span><br><span class="line">     */</span><br><span class="line">    vector&lt;int&gt; getRow(int rowIndex) &#123;</span><br><span class="line">        int n = rowIndex;</span><br><span class="line">        vector&lt;int&gt; a(n+1, 1);</span><br><span class="line">        vector&lt;int&gt; b(n+1, 1);</span><br><span class="line">        for (int i = 2; i &lt;= n; ++i) &#123;</span><br><span class="line">            for (int j = 1; j &lt; i; ++j) a[j] = b[j] + b[j-1];</span><br><span class="line">            for (int j = 1; j &lt; i; ++j) b[j] = a[j];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h2><p>描述</p>
<blockquote>
<p>给出一个值numRows，生成杨辉三角的前numRows行</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param numRows int整型 </span><br><span class="line">     * @return int整型vector&lt;vector&lt;&gt;&gt;</span><br><span class="line">     */</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; generate(int numRows) &#123;</span><br><span class="line">        int n = numRows;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; dp(n, vector&lt;int&gt;(n, 1));</span><br><span class="line">        for (int i = 2; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 1; j &lt; i; ++j) &#123;</span><br><span class="line">                dp[i][j] = dp[i-1][j-1] + dp[i-1][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            vector&lt;int&gt; tmp;</span><br><span class="line">            for (int j = 0; j &lt;= i; ++j) &#123;</span><br><span class="line">                tmp.push_back(dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="填充每个节点指向最右节点的next指针-ii"><a href="#填充每个节点指向最右节点的next指针-ii" class="headerlink" title="填充每个节点指向最右节点的next指针 ii"></a>填充每个节点指向最右节点的next指针 ii</h2><p>描述</p>
<blockquote>
<p>继续思考”填充每个节点指向最右节点的next指针” 这道题<br>如果给定的树可以是任意的二叉树呢?你之前的给出的算法还有效吗?<br>注意：<br>你只能使用常量的额外内存空间</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for binary tree with next pointer.</span><br><span class="line"> * struct TreeLinkNode &#123;</span><br><span class="line"> *  int val;</span><br><span class="line"> *  TreeLinkNode *left, *right, *next;</span><br><span class="line"> *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void connect(TreeLinkNode *root) &#123;</span><br><span class="line">        if (root == nullptr) return;</span><br><span class="line">        queue&lt;TreeLinkNode *&gt; q1;</span><br><span class="line">        queue&lt;TreeLinkNode *&gt; q2;</span><br><span class="line">        q1.push(root);</span><br><span class="line">        TreeLinkNode *nxt, *cur;</span><br><span class="line">        while (!q1.empty() || !q2.empty()) &#123;</span><br><span class="line">            while (!q1.empty()) &#123;</span><br><span class="line">                cur = q1.front();</span><br><span class="line">                q1.pop();</span><br><span class="line">                if (!q1.empty()) nxt = q1.front();</span><br><span class="line">                else nxt = nullptr;</span><br><span class="line">                cur-&gt;next = nxt;</span><br><span class="line">                if (cur-&gt;left) q2.push(cur-&gt;left);</span><br><span class="line">                if (cur-&gt;right) q2.push(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            while (!q2.empty()) &#123;</span><br><span class="line">                cur = q2.front();</span><br><span class="line">                q2.pop();</span><br><span class="line">                if (!q2.empty()) nxt = q2.front();</span><br><span class="line">                else nxt = nullptr;</span><br><span class="line">                cur-&gt;next = nxt;</span><br><span class="line">                if (cur-&gt;left) q1.push(cur-&gt;left);</span><br><span class="line">                if (cur-&gt;right) q1.push(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for binary tree with next pointer.</span><br><span class="line"> * struct TreeLinkNode &#123;</span><br><span class="line"> *  int val;</span><br><span class="line"> *  TreeLinkNode *left, *right, *next;</span><br><span class="line"> *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void connect(TreeLinkNode *root) &#123;</span><br><span class="line">        if (root == nullptr) return;</span><br><span class="line">        queue&lt;TreeLinkNode *&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        TreeLinkNode *cur;</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            int n = q.size();</span><br><span class="line">            while (n--) &#123;</span><br><span class="line">                cur = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                if (n == 0) cur-&gt;next = nullptr;</span><br><span class="line">                else cur-&gt;next = q.front();</span><br><span class="line">                if (cur-&gt;left) q.push(cur-&gt;left);</span><br><span class="line">                if (cur-&gt;right) q.push(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="填充每个节点指向最右节点的next指针"><a href="#填充每个节点指向最右节点的next指针" class="headerlink" title="填充每个节点指向最右节点的next指针"></a>填充每个节点指向最右节点的next指针</h2><p>描述</p>
<blockquote>
<p>给定一个二叉树<br>填充所有节点的next指针，指向最接近它的同一层右边节点。如果没有同一层没有右边的节点，则应该将next指针设置为NULL<br>初始时，所有的next指针都为NULL<br>注意：<br>你只能使用常量级的额外内存空间<br>可以假设给出的二叉树是一个完美的二叉树(即，所有叶子节点都位于同一层，而且每个父节点都有两个孩子节点)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for binary tree with next pointer.</span><br><span class="line"> * struct TreeLinkNode &#123;</span><br><span class="line"> *  int val;</span><br><span class="line"> *  TreeLinkNode *left, *right, *next;</span><br><span class="line"> *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void connect(TreeLinkNode *root) &#123;</span><br><span class="line">        if (!root) return;</span><br><span class="line">        TreeLinkNode *level = root;</span><br><span class="line">        TreeLinkNode *cur;</span><br><span class="line">        while (level) &#123;</span><br><span class="line">            cur = level;</span><br><span class="line">            while (cur) &#123;</span><br><span class="line">                if (cur-&gt;left) cur-&gt;left-&gt;next = cur-&gt;right;</span><br><span class="line">                if (cur-&gt;next &amp;&amp; cur-&gt;right) cur-&gt;right-&gt;next = cur-&gt;next-&gt;left;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            level = level-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="不同的子序列"><a href="#不同的子序列" class="headerlink" title="不同的子序列"></a>不同的子序列</h2><p>描述</p>
<blockquote>
<p>给定两个字符串S和T，返回S子序列等于T的不同子序列个数有多少个？<br>字符串的子序列是由原来的字符串删除一些字符（也可以不删除）在不改变相对位置的情况下的剩余字符（例如，”ACE”is a subsequence of”ABCDE”但是”AEC”不是）<br>例如：<br>S&#x3D;”nowcccoder”, T &#x3D; “nowccoder”<br>返回3</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param S string字符串 </span><br><span class="line">     * @param T string字符串 </span><br><span class="line">     * @return int整型</span><br><span class="line">     */</span><br><span class="line">    int numDistinct(string S, string T) &#123;</span><br><span class="line">        int n = S.size();</span><br><span class="line">        int m = T.size();</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; dp(n+1, vector&lt;int&gt;(m+1, 0));</span><br><span class="line">        for (int i = 0; i &lt;= n; ++i) dp[i][0] = 1;</span><br><span class="line">        for (int j = 1; j &lt;= m; ++j) dp[0][j] = 0;</span><br><span class="line">        for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= m; ++j) &#123;</span><br><span class="line">                if (S[i-1] != T[j-1]) dp[i][j] = dp[i-1][j];</span><br><span class="line">                else dp[i][j] = dp[i-1][j-1] + dp[i-1][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树中和为某一值的路径-二"><a href="#二叉树中和为某一值的路径-二" class="headerlink" title="二叉树中和为某一值的路径(二)"></a>二叉树中和为某一值的路径(二)</h2><p>描述</p>
<blockquote>
<p>输入一颗二叉树的根节点root和一个整数expectNumber，找出二叉树中结点值的和为expectNumber的所有路径<br>1.该题路径定义为从树的根结点开始往下一直到叶子结点所经过的结点<br>2.叶子节点是指没有子节点的节点<br>3.路径只能从父节点到子节点，不能从子节点到父节点<br>4.总节点数目为n</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *  int val;</span><br><span class="line"> *  struct TreeNode *left;</span><br><span class="line"> *  struct TreeNode *right;</span><br><span class="line"> *  TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="line">     *</span><br><span class="line">     * </span><br><span class="line">     * @param root TreeNode类 </span><br><span class="line">     * @param target int整型 </span><br><span class="line">     * @return int整型vector&lt;vector&lt;&gt;&gt;</span><br><span class="line">     */</span><br><span class="line">    void dfs(TreeNode *root, vector&lt;vector&lt;int&gt; &gt; &amp;res, vector&lt;int&gt; &amp;path, int &amp;sum, int target) &#123;</span><br><span class="line">        if (!root) return;</span><br><span class="line">        sum += root-&gt;val;</span><br><span class="line">        path.push_back(root-&gt;val);</span><br><span class="line">        if (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum == target) res.push_back(path);</span><br><span class="line">        dfs(root-&gt;left, res, path, sum, target);</span><br><span class="line">        dfs(root-&gt;right, res, path, sum, target);</span><br><span class="line"></span><br><span class="line">        path.pop_back();</span><br><span class="line">        sum -= root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root, int target) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">        vector&lt;int&gt; path;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        dfs(root, res, path, sum, target);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树中和为某一值的路径-一"><a href="#二叉树中和为某一值的路径-一" class="headerlink" title="二叉树中和为某一值的路径(一)"></a>二叉树中和为某一值的路径(一)</h2><p>描述</p>
<blockquote>
<p>给定一个二叉树root和一个值 sum ，判断是否有从根节点到叶子节点的节点值之和等于 sum 的路径<br>1.该题路径定义为从树的根结点开始往下一直到叶子结点所经过的结点<br>2.叶子节点是指没有子节点的节点<br>3.路径只能从父节点到子节点，不能从子节点到父节点<br>4.总节点数目为n</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *  int val;</span><br><span class="line"> *  struct TreeNode *left;</span><br><span class="line"> *  struct TreeNode *right;</span><br><span class="line"> *  TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="line">     *</span><br><span class="line">     * </span><br><span class="line">     * @param root TreeNode类 </span><br><span class="line">     * @param sum int整型 </span><br><span class="line">     * @return bool布尔型</span><br><span class="line">     */</span><br><span class="line">    bool hasPathSum(TreeNode* root, int sum) &#123;</span><br><span class="line">        if (root &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; root-&gt;val == sum) return true;</span><br><span class="line">        if (!root) return false;</span><br><span class="line">        return hasPathSum(root-&gt;left, sum-root-&gt;val) || hasPathSum(root-&gt;right, sum-root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *  int val;</span><br><span class="line"> *  struct TreeNode *left;</span><br><span class="line"> *  struct TreeNode *right;</span><br><span class="line"> *  TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="line">     *</span><br><span class="line">     * </span><br><span class="line">     * @param root TreeNode类 </span><br><span class="line">     * @param sum int整型 </span><br><span class="line">     * @return bool布尔型</span><br><span class="line">     */</span><br><span class="line">    bool dfs(TreeNode *root, int sum) &#123;</span><br><span class="line">        if (!root) return false;</span><br><span class="line">        if (root &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; root-&gt;val == sum) return true;</span><br><span class="line">        return dfs(root-&gt;left, sum-root-&gt;val) || dfs(root-&gt;right, sum-root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    bool hasPathSum(TreeNode* root, int sum) &#123;</span><br><span class="line">        return dfs(root, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="判断二叉树是否为平衡二叉树"><a href="#判断二叉树是否为平衡二叉树" class="headerlink" title="判断二叉树是否为平衡二叉树"></a>判断二叉树是否为平衡二叉树</h2><p>描述</p>
<blockquote>
<p>本题要求判断给定的二叉树是否是平衡二叉树<br>平衡二叉树的性质为: 要么是一棵空树，要么任何一个节点的左右子树高度差的绝对值不超过 1<br>一颗树的高度指的是树的根节点到所有节点的距离中的最大值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *  int val;</span><br><span class="line"> *  struct TreeNode *left;</span><br><span class="line"> *  struct TreeNode *right;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param root TreeNode类 </span><br><span class="line">     * @return bool布尔型</span><br><span class="line">     */</span><br><span class="line">    int depth(TreeNode *root) &#123;</span><br><span class="line">        if (!root) return 0;</span><br><span class="line">        int left = depth(root-&gt;left);</span><br><span class="line">        int right = depth(root-&gt;right);</span><br><span class="line">        return max(left, right) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isBalanced(TreeNode* root) &#123;</span><br><span class="line">        if (!root) return true;</span><br><span class="line">        int left = depth(root-&gt;left);</span><br><span class="line">        int right = depth(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        return isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right) &amp;&amp; abs(left-right) &lt;= 1; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="有序链表变成二叉搜索树"><a href="#有序链表变成二叉搜索树" class="headerlink" title="有序链表变成二叉搜索树"></a>有序链表变成二叉搜索树</h2><p>描述</p>
<blockquote>
<p>给定一个单链表，其中的元素按升序排序，请将它转化成平衡二叉搜索树（BST）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *  int val;</span><br><span class="line"> *  struct TreeNode *left;</span><br><span class="line"> *  struct TreeNode *right;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *  int val;</span><br><span class="line"> *  struct ListNode *next;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param head ListNode类 </span><br><span class="line">     * @return TreeNode类</span><br><span class="line">     */</span><br><span class="line">    TreeNode *merge(ListNode *head, ListNode *tail) &#123;</span><br><span class="line">        if (head == tail) return nullptr;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line">        while (fast != tail &amp;&amp; fast-&gt;next != tail) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode *root = new TreeNode(slow-&gt;val);</span><br><span class="line">        root-&gt;left = merge(head, slow);</span><br><span class="line">        root-&gt;right = merge(slow-&gt;next, tail);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* sortedListToBST(ListNode* head) &#123;</span><br><span class="line">        return merge(head, nullptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="将升序数组转化为平衡二叉搜索树"><a href="#将升序数组转化为平衡二叉搜索树" class="headerlink" title="将升序数组转化为平衡二叉搜索树"></a>将升序数组转化为平衡二叉搜索树</h2><p>描述</p>
<blockquote>
<p>给定一个升序排序的数组，将其转化为平衡二叉搜索树（BST）<br>平衡二叉搜索树指树上每个节点 node 都满足左子树中所有节点的的值都小于 node 的值，右子树中所有节点的值都大于 node 的值，并且左右子树的节点数量之差不大于1</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *  int val;</span><br><span class="line"> *  struct TreeNode *left;</span><br><span class="line"> *  struct TreeNode *right;</span><br><span class="line"> *  TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="line">     *</span><br><span class="line">     * </span><br><span class="line">     * @param nums int整型vector </span><br><span class="line">     * @return TreeNode类</span><br><span class="line">     */</span><br><span class="line">    TreeNode *merge(vector&lt;int&gt; &amp;nums, int left, int right) &#123;</span><br><span class="line">        if (left == right) return nullptr;</span><br><span class="line">        int mid = left + (right - left) / 2;</span><br><span class="line">        TreeNode *root = new TreeNode(nums[mid]);</span><br><span class="line">        root-&gt;left = merge(nums, left, mid);</span><br><span class="line">        root-&gt;right = merge(nums, mid+1, right);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        return merge(nums, 0, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树层序遍历-ii"><a href="#二叉树层序遍历-ii" class="headerlink" title="二叉树层序遍历 ii"></a>二叉树层序遍历 ii</h2><p>描述</p>
<blockquote>
<p>给定一个二叉树，返回该二叉树由底层到顶层的层序遍历，（从左向右，从叶子节点到根节点，一层一层的遍历）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *  int val;</span><br><span class="line"> *  struct TreeNode *left;</span><br><span class="line"> *  struct TreeNode *right;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param root TreeNode类 </span><br><span class="line">     * @return int整型vector&lt;vector&lt;&gt;&gt;</span><br><span class="line">     */</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">        if (!root) return res;</span><br><span class="line">        queue&lt;TreeNode *&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        TreeNode *cur;</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            int n = q.size();</span><br><span class="line">            vector&lt;int&gt; tmp;</span><br><span class="line">            while (n--) &#123;</span><br><span class="line">                cur = q.front();</span><br><span class="line">                tmp.push_back(cur-&gt;val);</span><br><span class="line">                q.pop();</span><br><span class="line">                if (cur-&gt;left) q.push(cur-&gt;left);</span><br><span class="line">                if (cur-&gt;right) q.push(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="从中序和后序遍历构造二叉树"><a href="#从中序和后序遍历构造二叉树" class="headerlink" title="从中序和后序遍历构造二叉树"></a>从中序和后序遍历构造二叉树</h2><p>描述</p>
<blockquote>
<p>给出一棵树的中序遍历和后序遍历，请构造这颗二叉树<br>注意：<br>保证给出的树中不存在重复的节点</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *  int val;</span><br><span class="line"> *  struct TreeNode *left;</span><br><span class="line"> *  struct TreeNode *right;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param inorder int整型vector </span><br><span class="line">     * @param postorder int整型vector </span><br><span class="line">     * @return TreeNode类</span><br><span class="line">     */</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;</span><br><span class="line">        int n = inorder.size();</span><br><span class="line">        if (n == 0) return nullptr;</span><br><span class="line">        if (n == 1) return new TreeNode(inorder[0]);</span><br><span class="line"></span><br><span class="line">        int index = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            if (inorder[i] == postorder[n-1]) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; leftInorder, leftPostorder, rightInorder, rightPostorder;</span><br><span class="line">        for (int i = 0; i &lt; index; ++i) leftInorder.push_back(inorder[i]);</span><br><span class="line">        for (int i = index + 1; i &lt; n; ++i) rightInorder.push_back(inorder[i]);</span><br><span class="line">        for (int i = index; i &lt; n - 1; ++i) rightPostorder.push_back(postorder[i]);</span><br><span class="line">        for (int i = 0; i &lt; index; ++i) leftPostorder.push_back(postorder[i]);</span><br><span class="line"></span><br><span class="line">        TreeNode *root = new TreeNode(inorder[index]);</span><br><span class="line"></span><br><span class="line">        root-&gt;left =  buildTree(leftInorder, leftPostorder);</span><br><span class="line">        root-&gt;right = buildTree(rightInorder, rightPostorder);</span><br><span class="line"></span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="从前序和中序遍历构造二叉树"><a href="#从前序和中序遍历构造二叉树" class="headerlink" title="从前序和中序遍历构造二叉树"></a>从前序和中序遍历构造二叉树</h2><p>描述</p>
<blockquote>
<p>给出一棵树的前序遍历和中序遍历，请构造这颗二叉树<br>注意：<br>可以假设树中不存在重复的节点</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *  int val;</span><br><span class="line"> *  struct TreeNode *left;</span><br><span class="line"> *  struct TreeNode *right;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param preorder int整型vector </span><br><span class="line">     * @param inorder int整型vector </span><br><span class="line">     * @return TreeNode类</span><br><span class="line">     */</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;</span><br><span class="line">        int n = preorder.size();</span><br><span class="line">        if (n == 0) return nullptr;</span><br><span class="line">        if (n == 1) return new TreeNode(preorder[0]);</span><br><span class="line"></span><br><span class="line">        int index = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            if (inorder[i] == preorder[0]) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; leftPreorder, leftInorder, rightPreorder, rightInorder;</span><br><span class="line">        TreeNode *root = new TreeNode(inorder[index]);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; index; ++i) leftInorder.push_back(inorder[i]);</span><br><span class="line">        for (int i = index+1; i &lt; n; ++i) rightInorder.push_back(inorder[i]);</span><br><span class="line">        for (int i = 1; i &lt;= index; ++i) leftPreorder.push_back(preorder[i]);</span><br><span class="line">        for (int i = index+1; i &lt; n; ++i) rightPreorder.push_back(preorder[i]);</span><br><span class="line"></span><br><span class="line">        root-&gt;left = buildTree(leftPreorder, leftInorder);</span><br><span class="line">        root-&gt;right = buildTree(rightPreorder, rightInorder);</span><br><span class="line"></span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h2><p>描述</p>
<blockquote>
<p>求给定二叉树的最大深度<br>深度是指树的根节点到任一叶子节点路径上节点的数量<br>最大深度是所有叶子节点的深度的最大值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *  int val;</span><br><span class="line"> *  struct TreeNode *left;</span><br><span class="line"> *  struct TreeNode *right;</span><br><span class="line"> *  TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="line">     *</span><br><span class="line">     * </span><br><span class="line">     * @param root TreeNode类 </span><br><span class="line">     * @return int整型</span><br><span class="line">     */</span><br><span class="line">    int maxDepth(TreeNode* root) &#123;</span><br><span class="line">        if (!root) return 0;</span><br><span class="line">        return max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="按之字形顺序打印二叉树"><a href="#按之字形顺序打印二叉树" class="headerlink" title="按之字形顺序打印二叉树"></a>按之字形顺序打印二叉树</h2><p>描述</p>
<blockquote>
<p>给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *  int val;</span><br><span class="line"> *  struct TreeNode *left;</span><br><span class="line"> *  struct TreeNode *right;</span><br><span class="line"> *  TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="line">     *</span><br><span class="line">     * </span><br><span class="line">     * @param pRoot TreeNode类 </span><br><span class="line">     * @return int整型vector&lt;vector&lt;&gt;&gt;</span><br><span class="line">     */</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">        if (!pRoot) return res;</span><br><span class="line">        queue&lt;TreeNode *&gt; q;</span><br><span class="line">        q.push(pRoot);</span><br><span class="line">        TreeNode *cur;</span><br><span class="line">        int level = 1;</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            vector&lt;int&gt; tmp;</span><br><span class="line">            int n = q.size();</span><br><span class="line">            while (n--) &#123;</span><br><span class="line">                cur = q.front();</span><br><span class="line">                tmp.push_back(cur-&gt;val);</span><br><span class="line">                q.pop();</span><br><span class="line">                if (cur-&gt;left) q.push(cur-&gt;left);</span><br><span class="line">                if (cur-&gt;right) q.push(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            if (level &amp; 1) res.push_back(tmp);</span><br><span class="line">            else &#123;</span><br><span class="line">                reverse(tmp.begin(), tmp.end());</span><br><span class="line">                res.push_back(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            ++level;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *  int val;</span><br><span class="line"> *  struct TreeNode *left;</span><br><span class="line"> *  struct TreeNode *right;</span><br><span class="line"> *  TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="line">     *</span><br><span class="line">     * </span><br><span class="line">     * @param pRoot TreeNode类 </span><br><span class="line">     * @return int整型vector&lt;vector&lt;&gt;&gt;</span><br><span class="line">     */</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">        if (!pRoot) return res;</span><br><span class="line">        stack&lt;TreeNode *&gt; s1, s2;</span><br><span class="line">        s1.push(pRoot);</span><br><span class="line">        TreeNode *cur;</span><br><span class="line">        while (!s1.empty() || !s2.empty()) &#123;</span><br><span class="line">            vector&lt;int&gt; tmp;</span><br><span class="line">            while (!s1.empty()) &#123;</span><br><span class="line">                cur = s1.top();</span><br><span class="line">                tmp.push_back(cur-&gt;val);</span><br><span class="line">                s1.pop();</span><br><span class="line">                if (cur-&gt;left) s2.push(cur-&gt;left);</span><br><span class="line">                if (cur-&gt;right) s2.push(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            if (!tmp.empty()) res.push_back(tmp);</span><br><span class="line">            tmp.clear();</span><br><span class="line">            while (!s2.empty()) &#123;</span><br><span class="line">                cur = s2.top();</span><br><span class="line">                tmp.push_back(cur-&gt;val);</span><br><span class="line">                s2.pop();</span><br><span class="line">                if (cur-&gt;right) s1.push(cur-&gt;right);</span><br><span class="line">                if (cur-&gt;left) s1.push(cur-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            if (!tmp.empty()) res.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="求二叉树的层序遍历"><a href="#求二叉树的层序遍历" class="headerlink" title="求二叉树的层序遍历"></a>求二叉树的层序遍历</h2><p>描述</p>
<blockquote>
<p>给定一个二叉树，返回该二叉树层序遍历的结果，（从左到右，一层一层地遍历）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *  int val;</span><br><span class="line"> *  struct TreeNode *left;</span><br><span class="line"> *  struct TreeNode *right;</span><br><span class="line"> *  TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="line">     *</span><br><span class="line">     * </span><br><span class="line">     * @param root TreeNode类 </span><br><span class="line">     * @return int整型vector&lt;vector&lt;&gt;&gt;</span><br><span class="line">     */</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">        if (!root) return res;</span><br><span class="line">        queue&lt;TreeNode *&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        TreeNode *cur;</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            int n = q.size();</span><br><span class="line">            vector&lt;int&gt; tmp;</span><br><span class="line">            while (n--) &#123;</span><br><span class="line">                cur = q.front();</span><br><span class="line">                tmp.push_back(cur-&gt;val);</span><br><span class="line">                q.pop();</span><br><span class="line">                if (cur-&gt;left) q.push(cur-&gt;left);</span><br><span class="line">                if (cur-&gt;right) q.push(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(tmp); </span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h2><p>描述</p>
<blockquote>
<p>给定一棵二叉树，判断其是否是自身的镜像（即：是否对称）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *  int val;</span><br><span class="line"> *  struct TreeNode *left;</span><br><span class="line"> *  struct TreeNode *right;</span><br><span class="line"> *  TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="line">     *</span><br><span class="line">     * </span><br><span class="line">     * @param pRoot TreeNode类 </span><br><span class="line">     * @return bool布尔型</span><br><span class="line">     */</span><br><span class="line">    bool same(TreeNode *r1, TreeNode *r2) &#123;</span><br><span class="line">        return (!r1 &amp;&amp; !r2) || (r1 &amp;&amp; r2 &amp;&amp; r1-&gt;val == r2-&gt;val &amp;&amp; same(r1-&gt;left, r2-&gt;left) &amp;&amp; same(r1-&gt;right, r2-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">    void mirror(TreeNode *root) &#123;</span><br><span class="line">        if (!root || (!root-&gt;left &amp;&amp; !root-&gt;right)) return;</span><br><span class="line">        TreeNode *left = root-&gt;left;</span><br><span class="line">        TreeNode *right = root-&gt;right;</span><br><span class="line">        mirror(left);</span><br><span class="line">        mirror(right);</span><br><span class="line">        root-&gt;left = right;</span><br><span class="line">        root-&gt;right = left;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isSymmetrical(TreeNode* pRoot) &#123;</span><br><span class="line">        if (!pRoot) return true;</span><br><span class="line">        mirror(pRoot-&gt;right);</span><br><span class="line">        return same(pRoot-&gt;left, pRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="判断二叉树是否相等"><a href="#判断二叉树是否相等" class="headerlink" title="判断二叉树是否相等"></a>判断二叉树是否相等</h2><p>描述</p>
<blockquote>
<p>给出两个二叉树，请写出一个判断两个二叉树是否相等的函数<br>判断两个二叉树相等的条件是：两个二叉树的结构相同，并且相同的节点上具有相同的值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *  int val;</span><br><span class="line"> *  struct TreeNode *left;</span><br><span class="line"> *  struct TreeNode *right;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param p TreeNode类 </span><br><span class="line">     * @param q TreeNode类 </span><br><span class="line">     * @return bool布尔型</span><br><span class="line">     */</span><br><span class="line">    bool isSameTree(TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        return (!p &amp;&amp; !q) || (p &amp;&amp; q &amp;&amp; p-&gt;val == q-&gt;val &amp;&amp; isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="恢复二叉搜索树"><a href="#恢复二叉搜索树" class="headerlink" title="恢复二叉搜索树"></a>恢复二叉搜索树</h2><p>描述</p>
<blockquote>
<p>二叉搜索树（BST）中的两个节点的值被错误地交换了<br>请在不改变树的结构的情况下恢复这棵树<br>备注；<br>用O(n)的空间解决这个问题的方法太暴力了，你能设计一个常数级空间复杂度的算法么？</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void inorder(TreeNode *root, TreeNode *&amp;pre, TreeNode *&amp;first, TreeNode *&amp;second) &#123;</span><br><span class="line">        if (!root) return;</span><br><span class="line">        inorder(root-&gt;left, pre, first, second);</span><br><span class="line">        if (pre &amp;&amp; pre-&gt;val &gt; root-&gt;val) &#123;</span><br><span class="line">            if (!first) first = pre;</span><br><span class="line">            second = root;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        inorder(root-&gt;right, pre, first, second);</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    void recoverTree(TreeNode *root) &#123;</span><br><span class="line">        TreeNode *pre = nullptr, *first = nullptr, *second = nullptr;</span><br><span class="line">        inorder(root, pre, first, second);</span><br><span class="line">        if (first &amp;&amp; second) swap(first-&gt;val, second-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    TreeNode *pre = nullptr, *first = nullptr, *second = nullptr;</span><br><span class="line">public:</span><br><span class="line">    void inorder(TreeNode *root) &#123;</span><br><span class="line">        if (!root) return;</span><br><span class="line">        inorder(root-&gt;left);</span><br><span class="line">        if (pre &amp;&amp; pre-&gt;val &gt; root-&gt;val) &#123;</span><br><span class="line">            if (!first) first = pre;</span><br><span class="line">            second = root;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        inorder(root-&gt;right);</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    void recoverTree(TreeNode *root) &#123;</span><br><span class="line">        inorder(root);</span><br><span class="line">        if (first &amp;&amp; second) swap(first-&gt;val, second-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="判断二叉搜索树"><a href="#判断二叉搜索树" class="headerlink" title="判断二叉搜索树"></a>判断二叉搜索树</h2><p>描述</p>
<blockquote>
<p>判断给出的二叉树是否是一个二叉搜索树（BST）<br>二叉搜索树的定义如下<br>一个节点的左子树上节点的值都小于自身的节点值<br>一个节点的右子树上节点的值都大于自身的节点值<br>所有节点的左右子树都必须是二叉搜索树</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *  int val;</span><br><span class="line"> *  struct TreeNode *left;</span><br><span class="line"> *  struct TreeNode *right;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    TreeNode *pre = nullptr;</span><br><span class="line">    bool flag = true;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param root TreeNode类 </span><br><span class="line">     * @return bool布尔型</span><br><span class="line">     */</span><br><span class="line">    void inorder(TreeNode *root) &#123;</span><br><span class="line">        if (!root) return;</span><br><span class="line">        inorder(root-&gt;left);</span><br><span class="line">        if (pre &amp;&amp; pre-&gt;val &gt;= root-&gt;val) flag = false;</span><br><span class="line">        pre = root;</span><br><span class="line">        inorder(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    bool isValidBST(TreeNode* root) &#123;</span><br><span class="line">        inorder(root);</span><br><span class="line">        return flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="交织的字符串"><a href="#交织的字符串" class="headerlink" title="交织的字符串"></a>交织的字符串</h2><p>描述</p>
<blockquote>
<p>给出三个字符串s1, s2, s3,判断s3是否可以由s1和s2交织而成<br>例如：<br>给定<br>s1 &#x3D;”xxyzz”,<br>s2 &#x3D;”pyyzx”,<br>如果s3 &#x3D;”xxpyyzyzxz”, 返回true<br>如果s3 &#x3D;”xxpyyyxzzz”, 返回false</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param s1 string字符串 </span><br><span class="line">     * @param s2 string字符串 </span><br><span class="line">     * @param s3 string字符串 </span><br><span class="line">     * @return bool布尔型</span><br><span class="line">     */</span><br><span class="line">    bool isInterleave(string s1, string s2, string s3) &#123;</span><br><span class="line">        int n = s1.size();</span><br><span class="line">        int m = s2.size();</span><br><span class="line">        int l = s3.size();</span><br><span class="line">        if (l != n + m) return false;</span><br><span class="line">        vector&lt;vector&lt;bool&gt;&gt; dp(n+1, vector&lt;bool&gt;(m+1, false));</span><br><span class="line">        dp[0][0] = true;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            if (s1[i] == s3[i]) dp[i+1][0] = true;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 0; j &lt; m; ++j) &#123;</span><br><span class="line">            if (s2[j] == s3[j]) dp[0][j+1] = true;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; ++j) &#123;</span><br><span class="line">                char a = s1[i], b = s2[j], c = s3[i+j+1];</span><br><span class="line">                if (a == c &amp;&amp; b != c) dp[i+1][j+1] = dp[i][j+1];</span><br><span class="line">                if (a != c &amp;&amp; b == c) dp[i+1][j+1] = dp[i+1][j];</span><br><span class="line">                if (a == c &amp;&amp; b == c) dp[i+1][j+1] = dp[i][j+1] || dp[i+1][j];</span><br><span class="line">                if (a != c &amp;&amp; b != c) dp[i+1][j+1] = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="不同的二叉搜索树-ii"><a href="#不同的二叉搜索树-ii" class="headerlink" title="不同的二叉搜索树 ii"></a>不同的二叉搜索树 ii</h2><p>描述</p>
<blockquote>
<p>给定一个值n,请生成所有的存储值1…n.的二叉搜索树（BST）的结构<br>例如：<br>给定n&#x3D;3，你的程序应该给出下面五种不同的二叉搜索树（BST）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *  int val;</span><br><span class="line"> *  struct TreeNode *left;</span><br><span class="line"> *  struct TreeNode *right;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param n int整型 </span><br><span class="line">     * @return TreeNode类vector</span><br><span class="line">     */</span><br><span class="line">    vector&lt;TreeNode *&gt; postorder(int left, int right) &#123;</span><br><span class="line">        if (left &gt; right) return vector&lt;TreeNode *&gt;&#123;nullptr&#125;;</span><br><span class="line">        vector&lt;TreeNode *&gt; res;</span><br><span class="line">        for (int i = left; i &lt;= right; ++i) &#123;</span><br><span class="line">            vector&lt;TreeNode *&gt; left_vec = postorder(left, i-1);</span><br><span class="line">            vector&lt;TreeNode *&gt; right_vec = postorder(i+1, right);</span><br><span class="line">            int n = left_vec.size();</span><br><span class="line">            int m = right_vec.size();</span><br><span class="line">            for (int a = 0; a &lt; n; ++a) &#123;</span><br><span class="line">                for (int b = 0; b &lt; m; ++b) &#123;</span><br><span class="line">                    TreeNode *root = new TreeNode(i);</span><br><span class="line">                    root-&gt;left = left_vec[a];</span><br><span class="line">                    root-&gt;right = right_vec[b];</span><br><span class="line">                    res.push_back(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;TreeNode*&gt; generateTrees(int n) &#123;</span><br><span class="line">        return postorder(1, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h2><p>描述</p>
<blockquote>
<p>给定一个值n，能构建出多少不同的值包含1…n的二叉搜索树（BST）？<br>例如<br>给定 n &#x3D; 3, 有五种不同的二叉搜索树（BST）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param n int整型 </span><br><span class="line">     * @return int整型</span><br><span class="line">     */</span><br><span class="line">    int postorder(int left, int right) &#123;</span><br><span class="line">        if (left &gt; right) return 0;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = left; i &lt;= right; ++i) &#123;</span><br><span class="line">            int l = postorder(left, i-1);</span><br><span class="line">            int r = postorder(i+1, right);</span><br><span class="line">            if (l != 0 &amp;&amp; r != 0) res += l * r;</span><br><span class="line">            else if (l == 0 &amp;&amp; r == 0) res += 1;</span><br><span class="line">            else if (l == 0) res += r;</span><br><span class="line">            else res += l;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    int numTrees(int n) &#123;</span><br><span class="line">        return postorder(1, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param n int整型 </span><br><span class="line">     * @return int整型</span><br><span class="line">     */</span><br><span class="line">    int numTrees(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(n+1, 0);</span><br><span class="line">        dp[0] = 1, dp[1] = 1;</span><br><span class="line">        for (int i = 2; i &lt;= n; ++i) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= i; ++j) &#123;</span><br><span class="line">                dp[i] += dp[j-1] * dp[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h2><p>描述</p>
<blockquote>
<p>给出一棵二叉树，返回这棵树的中序遍历<br>例如：<br>给出的二叉树为{1,#,2,3}</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *  int val;</span><br><span class="line"> *  struct TreeNode *left;</span><br><span class="line"> *  struct TreeNode *right;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param root TreeNode类 </span><br><span class="line">     * @return int整型vector</span><br><span class="line">     */</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if (!root) return res;</span><br><span class="line">        stack&lt;TreeNode *&gt; s;</span><br><span class="line">        TreeNode *cur = root;</span><br><span class="line">        while (!s.empty() || cur) &#123;</span><br><span class="line">            while (cur) &#123;</span><br><span class="line">                s.push(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = s.top();</span><br><span class="line">            res.push_back(cur-&gt;val);</span><br><span class="line">            s.pop();</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="数字字符串转化成IP地址"><a href="#数字字符串转化成IP地址" class="headerlink" title="数字字符串转化成IP地址"></a>数字字符串转化成IP地址</h2><blockquote>
<p>描述<br>现在有一个只包含数字的字符串，将该字符串转化成IP地址的形式，返回所有可能的情况。<br>例如：<br>给出的字符串为”25525522135”,<br>返回[“255.255.22.135”, “255.255.221.35”]. (顺序没有关系)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param s string字符串 </span><br><span class="line">     * @return string字符串vector</span><br><span class="line">     */</span><br><span class="line">    void dfs(string &amp;s, vector&lt;string&gt; &amp;result, vector&lt;int&gt; segments, int seg_id, int seg_start, int n) &#123;</span><br><span class="line">        if (seg_id == 4) &#123;</span><br><span class="line">            if (seg_start == n) &#123;</span><br><span class="line">                string addr = &quot;&quot;;</span><br><span class="line">                for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">                    addr += to_string(segments[i]);</span><br><span class="line">                    if (i != 3) addr += &quot;.&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">                result.push_back(addr);</span><br><span class="line">            &#125; else return;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (seg_start == n) return;</span><br><span class="line">            if (s[seg_start] == &#x27;0&#x27;) &#123;</span><br><span class="line">                segments.push_back(0);</span><br><span class="line">                dfs(s, result, segments, seg_id+1, seg_start+1, n);</span><br><span class="line">                segments.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            int code = 0;</span><br><span class="line">            for (int seg_end = seg_start; seg_end &lt; n; ++seg_end) &#123;</span><br><span class="line">                code = code * 10 + (s[seg_end] - &#x27;0&#x27;);</span><br><span class="line">                if (code &gt; 0 &amp;&amp; code &lt;= 0xFF) &#123;</span><br><span class="line">                    segments.push_back(code);</span><br><span class="line">                    dfs(s, result, segments, seg_id+1, seg_end+1, n);</span><br><span class="line">                    segments.pop_back();</span><br><span class="line">                &#125; else break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;string&gt; restoreIpAddresses(string s) &#123;</span><br><span class="line">        // write code here</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        vector&lt;int&gt; segments;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        if (n == 0) return result;</span><br><span class="line">        dfs(s, result, segments, 0, 0, n);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="链表内指定区间反转"><a href="#链表内指定区间反转" class="headerlink" title="链表内指定区间反转"></a>链表内指定区间反转</h2><blockquote>
<p>描述<br>将一个节点数为 size 链表 m 位置到 n 位置之间的区间反转，要求时间复杂度 O(n)，空间复杂度 O(1)。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *	int val;</span><br><span class="line"> *	struct ListNode *next;</span><br><span class="line"> *	ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="line">     *</span><br><span class="line">     * </span><br><span class="line">     * @param head ListNode类 </span><br><span class="line">     * @param m int整型 </span><br><span class="line">     * @param n int整型 </span><br><span class="line">     * @return ListNode类</span><br><span class="line">     */</span><br><span class="line">    ListNode* reverseBetween(ListNode* head, int m, int n) &#123;</span><br><span class="line">        // write code here</span><br><span class="line">        if (head == nullptr) return nullptr;</span><br><span class="line">        auto *dummy = new ListNode(0);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode *pre_begin = nullptr, *nxt_end = nullptr, *begin = nullptr, *end = nullptr;</span><br><span class="line">        ListNode *cur = head, *pre = dummy, *nxt = nullptr;</span><br><span class="line">        int i = 1;</span><br><span class="line">        while (i &lt; m) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        pre_begin = pre;</span><br><span class="line">        begin = cur;</span><br><span class="line">        cur = head;</span><br><span class="line">        i = 1;  </span><br><span class="line">        while (i &lt; n) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        end = cur;</span><br><span class="line">        nxt_end = end-&gt;next;</span><br><span class="line">        end-&gt;next = nullptr;</span><br><span class="line"></span><br><span class="line">        cur = begin;</span><br><span class="line">        pre = nullptr;</span><br><span class="line">        while (cur) &#123;</span><br><span class="line">            nxt = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        pre_begin-&gt;next = end;</span><br><span class="line">        begin-&gt;next = nxt_end;</span><br><span class="line">        return dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="子集-ii"><a href="#子集-ii" class="headerlink" title="子集-ii"></a>子集-ii</h2><p>描述</p>
<blockquote>
<p>给出一个可能包含重复元素的整数集合S，返回该整数集合的所有子集。<br>注意：你给出的子集中的元素要按非递减的顺序排列,给出的解集中不能包含重复的子集</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(set&lt;vector&lt;int&gt;&gt; &amp;res, vector&lt;int&gt; &amp;path, vector&lt;int&gt; &amp;S, int index, int n) &#123;</span><br><span class="line">        res.insert(path);</span><br><span class="line">        if (index == n) return;</span><br><span class="line">        dfs(res, path, S, index+1, n);</span><br><span class="line">        path.push_back(S[index]);</span><br><span class="line">        dfs(res, path, S, index+1, n);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; subsetsWithDup(vector&lt;int&gt; &amp;S) &#123;</span><br><span class="line">        int n = S.size();</span><br><span class="line">        set&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">        vector&lt;int&gt; path;</span><br><span class="line">        sort(S.begin(), S.end());</span><br><span class="line">        dfs(res, path, S, 0, n);</span><br><span class="line">        return vector&lt;vector&lt;int&gt; &gt;(res.begin(), res.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h2><p>描述</p>
<blockquote>
<p>一条仅包含字母‘A’-‘Z’的消息用下列的方式加密成数字<br>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26<br>现在给出加密成数字的密文，请判断有多少种解密的方法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param s string字符串 </span><br><span class="line">     * @return int整型</span><br><span class="line">     */</span><br><span class="line">    int numDecodings(string s) &#123;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        if (n == 0) return 0;</span><br><span class="line">        if (s == &quot;0&quot;) return 0;</span><br><span class="line">        int index = s.rfind(&#x27;0&#x27;);</span><br><span class="line">        if (index == 0) return 0;</span><br><span class="line">        if (index &gt; 0 &amp;&amp; s[index-1] != &#x27;1&#x27; &amp;&amp; s[index-1] != &#x27;2&#x27;) return 0;</span><br><span class="line">        vector&lt;int&gt; dp(n, 1);</span><br><span class="line">        for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">            if ((s[i-1] == &#x27;1&#x27; &amp;&amp; s[i] != &#x27;0&#x27;) || (s[i-1] == &#x27;2&#x27; &amp;&amp; s[i] &gt;= &#x27;1&#x27; &amp;&amp; s[i] &lt;= &#x27;6&#x27;)) &#123;</span><br><span class="line">                if (i == 1) dp[i] = 2;</span><br><span class="line">                else dp[i] = dp[i-1] + dp[i-2];</span><br><span class="line">            &#125;</span><br><span class="line">            else if (s[i] == &#x27;0&#x27;) &#123;</span><br><span class="line">                 if (i == 1) dp[i] = 1;</span><br><span class="line">                 else dp[i] = dp[i-2];</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                dp[i] = dp[i-1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="格雷码"><a href="#格雷码" class="headerlink" title="格雷码"></a>格雷码</h2><p>描述</p>
<blockquote>
<p>格雷码是一种二进制编码系统，如果任意两个相邻的代码只有一位二进制数不同，则称这种编码为格雷码（Gray Code）<br>给定一个非负整数n，表示代码的位数，打印格雷码的序列。格雷码序列必须以0开头</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param n int整型 </span><br><span class="line">     * @return int整型vector</span><br><span class="line">     */</span><br><span class="line">    vector&lt;int&gt; grayCode(int n) &#123;</span><br><span class="line">       vector&lt;int&gt; res;</span><br><span class="line">       res.push_back(0);</span><br><span class="line">       if (n == 0) return res;</span><br><span class="line">       for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">            int m = res.size();</span><br><span class="line">            for (int j = m - 1; j &gt;= 0; --j) &#123;</span><br><span class="line">                res.push_back(res[j] | (1 &lt;&lt; (i-1)));</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="合并两个有序的数组"><a href="#合并两个有序的数组" class="headerlink" title="合并两个有序的数组"></a>合并两个有序的数组</h2><p>描述</p>
<blockquote>
<p>给出一个有序的整数数组 A 和有序的整数数组 B ，请将数组 B 合并到数组 A 中，变成一个有序的升序数组</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void merge(int A[], int m, int B[], int n) &#123;</span><br><span class="line">//         for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">//             A[m + i] = B[i];</span><br><span class="line">//         &#125;</span><br><span class="line">//         sort(A, A + m + n);</span><br><span class="line">        if (n == 0) return;</span><br><span class="line">        if (m == 0) &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                A[j] = B[j];</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int i = m - 1, j = n - 1, index = m + n - 1;</span><br><span class="line">        while (i &gt;= 0 &amp;&amp; j &gt;= 0) &#123;</span><br><span class="line">            if (A[i] &gt; B[j]) A[index--] = A[i--];</span><br><span class="line">            else A[index--] = B[j--];</span><br><span class="line">        &#125;</span><br><span class="line">        while (j &gt;= 0) &#123;</span><br><span class="line">            A[index--] = B[j--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="搅乱字符串"><a href="#搅乱字符串" class="headerlink" title="搅乱字符串"></a>搅乱字符串</h2><p>描述</p>
<blockquote>
<p>给出两个长度相同的字符串s1 和 s2，请判断s2是否是s1的乱序字符串</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param s1 string字符串 </span><br><span class="line">     * @param s2 string字符串 </span><br><span class="line">     * @return bool布尔型</span><br><span class="line">     */</span><br><span class="line">    bool dfs(string s1, string s2) &#123;</span><br><span class="line">        int n = s1.size(), m = s2.size();</span><br><span class="line">        if (n != m) return false;</span><br><span class="line">        if (s1 == s2) return true;</span><br><span class="line">        unordered_map&lt;char, int&gt; mp;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            ++mp[s1[i]]; --mp[s2[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        for (auto it = mp.begin(); it != mp.end(); ++it) &#123;</span><br><span class="line">            if (it-&gt;second != 0) return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">            if (dfs(s1.substr(0, i), s2.substr(0, i)) &amp;&amp; dfs(s1.substr(i), s2.substr(i))) return true;</span><br><span class="line">            if (dfs(s1.substr(0, i), s2.substr(n-i)) &amp;&amp; dfs(s1.substr(i), s2.substr(0, n-i))) return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isScramble(string s1, string s2) &#123;</span><br><span class="line">        return dfs(s1, s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="划分链表"><a href="#划分链表" class="headerlink" title="划分链表"></a>划分链表</h2><p>描述</p>
<blockquote>
<p>给出一个长度为 n 的单链表和一个值 x ，单链表的每一个值为 listi ，请返回一个链表的头结点，要求新链表中小于 x 的节点全部在大于等于 x 的节点左侧，并且两个部分之内的节点之间与原来的链表要保持相对顺序不变</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *	int val;</span><br><span class="line"> *	struct ListNode *next;</span><br><span class="line"> *	ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="line">     *</span><br><span class="line">     * </span><br><span class="line">     * @param head ListNode类 </span><br><span class="line">     * @param x int整型 </span><br><span class="line">     * @return ListNode类</span><br><span class="line">     */</span><br><span class="line">    ListNode* partition(ListNode* head, int x) &#123;</span><br><span class="line">        if (!head || !head-&gt;next) return head;</span><br><span class="line">        ListNode *d1 = new ListNode(-1);</span><br><span class="line">        ListNode *d2 = new ListNode(-1);</span><br><span class="line">        ListNode *t1 = d1, *t2 = d2;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        while (cur) &#123;</span><br><span class="line">            if (cur-&gt;val &lt; x) &#123;</span><br><span class="line">                t1-&gt;next = cur;</span><br><span class="line">                t1 = t1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                t2-&gt;next = cur;</span><br><span class="line">                t2 = t2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        t1-&gt;next = d2-&gt;next;</span><br><span class="line">        t2-&gt;next = nullptr;</span><br><span class="line">        return d1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最大的长方形"><a href="#最大的长方形" class="headerlink" title="最大的长方形"></a>最大的长方形</h2><p>描述</p>
<blockquote>
<p>给出一个只包含0和1的二维矩阵，找出最大的全部元素都是1的长方形区域，返回该区域的面积</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maximalRectangle(vector&lt;vector&lt;char&gt; &gt; &amp;matrix) &#123;</span><br><span class="line">        int n = matrix.size();</span><br><span class="line">        if (n == 0) return 0;</span><br><span class="line">        int m = matrix[0].size();</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; hist(n, vector&lt;int&gt;(m, 0));</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; ++j) &#123;</span><br><span class="line">                if (matrix[i][j] == &#x27;1&#x27;) &#123;</span><br><span class="line">                    int index = i;</span><br><span class="line">                    int ans = 0;</span><br><span class="line">                    while (index &gt;= 0 &amp;&amp; matrix[index][j] == &#x27;1&#x27;) &#123;</span><br><span class="line">                        ++ans;</span><br><span class="line">                        --index;</span><br><span class="line">                    &#125;</span><br><span class="line">                    hist[i][j] = ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            stack&lt;int&gt; mono_stack;</span><br><span class="line">            vector&lt;int&gt; left(m, -1), right(m, m);</span><br><span class="line">            for (int j = 0; j &lt; m; ++j) &#123;</span><br><span class="line">                while (!mono_stack.empty() &amp;&amp; hist[i][mono_stack.top()] &gt;= hist[i][j]) &#123;</span><br><span class="line">                    right[mono_stack.top()] = j;</span><br><span class="line">                    mono_stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                left[j] = mono_stack.empty() ? -1 : mono_stack.top();</span><br><span class="line">                mono_stack.push(j);</span><br><span class="line">            &#125;</span><br><span class="line">            for (int j = 0; j &lt; m; ++j) &#123;</span><br><span class="line">                res = max(res, (right[j] - left[j] - 1) * hist[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="直方图中的最大矩形"><a href="#直方图中的最大矩形" class="headerlink" title="直方图中的最大矩形"></a>直方图中的最大矩形</h2><p>描述</p>
<blockquote>
<p>给出n个数字，代表直方图的条高，直方图每一条的宽度为1，请计算直方图中最大矩形的面积</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param height int整型vector </span><br><span class="line">     * @return int整型</span><br><span class="line">     */</span><br><span class="line">    int largestRectangleArea(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line">        int n = height.size();</span><br><span class="line">        if (n == 0) return 0;</span><br><span class="line">        vector&lt;int&gt; left(n, -1);</span><br><span class="line">        vector&lt;int&gt; right(n, n);</span><br><span class="line">        stack&lt;int&gt; mono_stack;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            while (!mono_stack.empty() &amp;&amp; height[mono_stack.top()] &gt;= height[i]) &#123;</span><br><span class="line">                right[mono_stack.top()] = i;</span><br><span class="line">                mono_stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = mono_stack.empty() ? -1 : mono_stack.top();</span><br><span class="line">            mono_stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            ans = max(ans, (right[i] - left[i] - 1) * height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="删除有序链表中重复的元素-II"><a href="#删除有序链表中重复的元素-II" class="headerlink" title="删除有序链表中重复的元素-II"></a>删除有序链表中重复的元素-II</h2><p>描述</p>
<blockquote>
<p>给出一个升序排序的链表，删除链表中的所有重复出现的元素，只保留原链表中只出现一次的元素</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *	int val;</span><br><span class="line"> *	struct ListNode *next;</span><br><span class="line"> *	ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="line">     *</span><br><span class="line">     * </span><br><span class="line">     * @param head ListNode类 </span><br><span class="line">     * @return ListNode类</span><br><span class="line">     */</span><br><span class="line">    ListNode* deleteDuplicates(ListNode* head) &#123;</span><br><span class="line">        if (!head || !head-&gt;next) return head;</span><br><span class="line">        ListNode *dummy = new ListNode(0);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode *pre = dummy, *cur = head;</span><br><span class="line">        while (cur) &#123;</span><br><span class="line">            if (!cur-&gt;next || cur-&gt;next &amp;&amp; cur-&gt;val != cur-&gt;next-&gt;val) &#123;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125; </span><br><span class="line">            else &#123;</span><br><span class="line">                while (cur-&gt;next &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val) cur = cur-&gt;next;</span><br><span class="line">                pre-&gt;next = cur-&gt;next;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="删除有序链表中重复的元素-I"><a href="#删除有序链表中重复的元素-I" class="headerlink" title="删除有序链表中重复的元素-I"></a>删除有序链表中重复的元素-I</h2><p>描述</p>
<blockquote>
<p>删除给出链表中的重复元素（链表中元素从小到大有序），使链表中的所有元素都只出现一次</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *	int val;</span><br><span class="line"> *	struct ListNode *next;</span><br><span class="line"> *	ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="line">     *</span><br><span class="line">     * </span><br><span class="line">     * @param head ListNode类 </span><br><span class="line">     * @return ListNode类</span><br><span class="line">     */</span><br><span class="line">    ListNode* deleteDuplicates(ListNode* head) &#123;</span><br><span class="line">        // write code here</span><br><span class="line">        if (head == nullptr) return nullptr;</span><br><span class="line">        ListNode *pre = head, *cur = head;</span><br><span class="line">        while (cur) &#123;</span><br><span class="line">           while (cur-&gt;next != nullptr &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val) &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">           pre-&gt;next = cur-&gt;next;</span><br><span class="line">           pre = pre-&gt;next;</span><br><span class="line">           if (pre == nullptr) return head;</span><br><span class="line">           else cur = pre;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Algorithm/" rel="tag"># Algorithm</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2023/09/12/%E5%89%91%E6%8C%87Offer/" rel="next" title="剑指Offer">
                <i class="fa fa-chevron-left"></i> 剑指Offer
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2023/12/12/Links/" rel="prev" title="Links">
                Links <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/xiadx" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6"><span class="nav-number">1.</span> <span class="nav-text">二叉树的最小深度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="nav-number">2.</span> <span class="nav-text">后缀表达式求值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E5%B0%91%E4%B8%AA%E7%82%B9%E4%BD%8D%E4%BA%8E%E5%90%8C%E4%B8%80%E7%9B%B4%E7%BA%BF"><span class="nav-number">3.</span> <span class="nav-text">多少个点位于同一直线</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F"><span class="nav-number">4.</span> <span class="nav-text">链表排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">5.</span> <span class="nav-text">链表的插入排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">6.</span> <span class="nav-text">二叉树的后序遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">7.</span> <span class="nav-text">求二叉树的前序遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8"><span class="nav-number">8.</span> <span class="nav-text">重排链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9"><span class="nav-number">9.</span> <span class="nav-text">链表中环的入口结点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF"><span class="nav-number">10.</span> <span class="nav-text">判断链表中是否有环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%86%E5%88%86%E8%AF%8D%E5%8F%A5"><span class="nav-number">11.</span> <span class="nav-text">拆分词句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97ii"><span class="nav-number">12.</span> <span class="nav-text">出现一次的数字ii</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">13.</span> <span class="nav-text">出现一次的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E7%B3%96%E6%9E%9C"><span class="nav-number">14.</span> <span class="nav-text">分糖果</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A0%E6%B2%B9%E7%AB%99"><span class="nav-number">15.</span> <span class="nav-text">加油站</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E6%97%A0%E5%90%91%E5%9B%BE"><span class="nav-number">16.</span> <span class="nav-text">复制无向图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2-ii"><span class="nav-number">17.</span> <span class="nav-text">分割回文串-ii</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="nav-number">18.</span> <span class="nav-text">分割回文串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%85%E5%9B%B4%E5%8C%BA%E5%9F%9F"><span class="nav-number">19.</span> <span class="nav-text">包围区域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="nav-number">20.</span> <span class="nav-text">二叉树根节点到叶子节点的所有路径和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E7%9A%84%E8%BF%9E%E7%BB%AD%E5%85%83%E7%B4%A0%E5%BA%8F%E5%88%97%E9%95%BF%E5%BA%A6"><span class="nav-number">21.</span> <span class="nav-text">最长的连续元素序列长度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%8D%E8%AF%AD%E5%BA%8F%E5%88%97"><span class="nav-number">22.</span> <span class="nav-text">词语序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="nav-number">23.</span> <span class="nav-text">判断回文串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="nav-number">24.</span> <span class="nav-text">二叉树中的最大路径和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A5%BD%E6%97%B6%E6%9C%BA-iii"><span class="nav-number">25.</span> <span class="nav-text">买卖股票的最好时机 iii</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A5%BD%E6%97%B6%E6%9C%BA-ii"><span class="nav-number">26.</span> <span class="nav-text">买卖股票的最好时机 ii</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A5%BD%E6%97%B6%E6%9C%BA"><span class="nav-number">27.</span> <span class="nav-text">买卖股票的最好时机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="nav-number">28.</span> <span class="nav-text">三角形</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92-ii"><span class="nav-number">29.</span> <span class="nav-text">杨辉三角-ii</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92"><span class="nav-number">30.</span> <span class="nav-text">杨辉三角</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E6%8C%87%E5%90%91%E6%9C%80%E5%8F%B3%E8%8A%82%E7%82%B9%E7%9A%84next%E6%8C%87%E9%92%88-ii"><span class="nav-number">31.</span> <span class="nav-text">填充每个节点指向最右节点的next指针 ii</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E6%8C%87%E5%90%91%E6%9C%80%E5%8F%B3%E8%8A%82%E7%82%B9%E7%9A%84next%E6%8C%87%E9%92%88"><span class="nav-number">32.</span> <span class="nav-text">填充每个节点指向最右节点的next指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">33.</span> <span class="nav-text">不同的子序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84-%E4%BA%8C"><span class="nav-number">34.</span> <span class="nav-text">二叉树中和为某一值的路径(二)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84-%E4%B8%80"><span class="nav-number">35.</span> <span class="nav-text">二叉树中和为某一值的路径(一)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E4%B8%BA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">36.</span> <span class="nav-text">判断二叉树是否为平衡二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%8F%98%E6%88%90%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">37.</span> <span class="nav-text">有序链表变成二叉搜索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%86%E5%8D%87%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">38.</span> <span class="nav-text">将升序数组转化为平衡二叉搜索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-ii"><span class="nav-number">39.</span> <span class="nav-text">二叉树层序遍历 ii</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">40.</span> <span class="nav-text">从中序和后序遍历构造二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">41.</span> <span class="nav-text">从前序和中序遍历构造二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="nav-number">42.</span> <span class="nav-text">二叉树的最大深度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">43.</span> <span class="nav-text">按之字形顺序打印二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">44.</span> <span class="nav-text">求二叉树的层序遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">45.</span> <span class="nav-text">对称的二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89"><span class="nav-number">46.</span> <span class="nav-text">判断二叉树是否相等</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">47.</span> <span class="nav-text">恢复二叉搜索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">48.</span> <span class="nav-text">判断二叉搜索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%A4%E7%BB%87%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">49.</span> <span class="nav-text">交织的字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-ii"><span class="nav-number">50.</span> <span class="nav-text">不同的二叉搜索树 ii</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">51.</span> <span class="nav-text">不同的二叉搜索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">52.</span> <span class="nav-text">二叉树的中序遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E6%88%90IP%E5%9C%B0%E5%9D%80"><span class="nav-number">53.</span> <span class="nav-text">数字字符串转化成IP地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E5%86%85%E6%8C%87%E5%AE%9A%E5%8C%BA%E9%97%B4%E5%8F%8D%E8%BD%AC"><span class="nav-number">54.</span> <span class="nav-text">链表内指定区间反转</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%90%E9%9B%86-ii"><span class="nav-number">55.</span> <span class="nav-text">子集-ii</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E5%AF%86"><span class="nav-number">56.</span> <span class="nav-text">解密</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%BC%E9%9B%B7%E7%A0%81"><span class="nav-number">57.</span> <span class="nav-text">格雷码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84"><span class="nav-number">58.</span> <span class="nav-text">合并两个有序的数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%90%85%E4%B9%B1%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">59.</span> <span class="nav-text">搅乱字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%92%E5%88%86%E9%93%BE%E8%A1%A8"><span class="nav-number">60.</span> <span class="nav-text">划分链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E7%9A%84%E9%95%BF%E6%96%B9%E5%BD%A2"><span class="nav-number">61.</span> <span class="nav-text">最大的长方形</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B4%E6%96%B9%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2"><span class="nav-number">62.</span> <span class="nav-text">直方图中的最大矩形</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E5%85%83%E7%B4%A0-II"><span class="nav-number">63.</span> <span class="nav-text">删除有序链表中重复的元素-II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E5%85%83%E7%B4%A0-I"><span class="nav-number">64.</span> <span class="nav-text">删除有序链表中重复的元素-I</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dingxin</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
